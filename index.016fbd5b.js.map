{"mappings":"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","sources":["<anon>","build/init.js","build/app.js"],"sourcesContent":["console.log(\"init app.js module...\");\nclass $7fc2474486b8416c$var$Ghost {\n    constructor(scaledTileSize, mazeArray, pacman, name, level, characterUtil, blinky){\n        this.scaledTileSize = scaledTileSize;\n        this.mazeArray = mazeArray;\n        this.pacman = pacman;\n        this.name = name;\n        this.level = level;\n        this.characterUtil = characterUtil;\n        this.blinky = blinky;\n        this.animationTarget = document.getElementById(name);\n        this.reset();\n    }\n    /**\n   * Rests the character to its default state\n   * @param {Boolean} fullGameReset\n   */ reset(fullGameReset) {\n        if (fullGameReset) {\n            delete this.defaultSpeed;\n            delete this.cruiseElroy;\n        }\n        this.setDefaultMode();\n        this.setMovementStats(this.pacman, this.name, this.level);\n        this.setSpriteAnimationStats();\n        this.setStyleMeasurements(this.scaledTileSize, this.spriteFrames);\n        this.setDefaultPosition(this.scaledTileSize, this.name);\n        this.setSpriteSheet(this.name, this.direction, this.mode);\n    }\n    /**\n   * Sets the default mode and idleMode behavior\n   */ setDefaultMode() {\n        this.allowCollision = true;\n        this.defaultMode = \"scatter\";\n        this.mode = \"scatter\";\n        if (this.name !== \"blinky\") this.idleMode = \"idle\";\n    }\n    /**\n   * Sets various properties related to the ghost's movement\n   * @param {Object} pacman - Pacman's speed is used as the base for the ghosts' speeds\n   * @param {('inky'|'blinky'|'pinky'|'clyde')} name - The name of the current ghost\n   */ setMovementStats(pacman, name, level) {\n        const pacmanSpeed = pacman.velocityPerMs;\n        const levelAdjustment = level / 100;\n        this.slowSpeed = pacmanSpeed * (0.75 + levelAdjustment);\n        this.mediumSpeed = pacmanSpeed * (0.875 + levelAdjustment);\n        this.fastSpeed = pacmanSpeed * (1 + levelAdjustment);\n        if (!this.defaultSpeed) this.defaultSpeed = this.slowSpeed;\n        this.scaredSpeed = pacmanSpeed * 0.5;\n        this.transitionSpeed = pacmanSpeed * 0.4;\n        this.eyeSpeed = pacmanSpeed * 2;\n        this.velocityPerMs = this.defaultSpeed;\n        this.moving = false;\n        switch(name){\n            case \"blinky\":\n                this.defaultDirection = this.characterUtil.directions.left;\n                break;\n            case \"pinky\":\n                this.defaultDirection = this.characterUtil.directions.down;\n                break;\n            case \"inky\":\n                this.defaultDirection = this.characterUtil.directions.up;\n                break;\n            case \"clyde\":\n                this.defaultDirection = this.characterUtil.directions.up;\n                break;\n            default:\n                this.defaultDirection = this.characterUtil.directions.left;\n                break;\n        }\n        this.direction = this.defaultDirection;\n    }\n    /**\n   * Sets values pertaining to the ghost's spritesheet animation\n   */ setSpriteAnimationStats() {\n        this.display = true;\n        this.loopAnimation = true;\n        this.animate = true;\n        this.msBetweenSprites = 250;\n        this.msSinceLastSprite = 0;\n        this.spriteFrames = 2;\n        this.backgroundOffsetPixels = 0;\n        this.animationTarget.style.backgroundPosition = \"0px 0px\";\n    }\n    /**\n   * Sets css property values for the ghost\n   * @param {number} scaledTileSize - The dimensions of a single tile\n   * @param {number} spriteFrames - The number of frames in the ghost's spritesheet\n   */ setStyleMeasurements(scaledTileSize, spriteFrames) {\n        // The ghosts are the size of 2x2 game tiles.\n        this.measurement = scaledTileSize * 2;\n        this.animationTarget.style.height = `${this.measurement}px`;\n        this.animationTarget.style.width = `${this.measurement}px`;\n        const bgSize = this.measurement * spriteFrames;\n        this.animationTarget.style.backgroundSize = `${bgSize}px`;\n    }\n    /**\n   * Sets the default position and direction for the ghosts at the game's start\n   * @param {number} scaledTileSize - The dimensions of a single tile\n   * @param {('inky'|'blinky'|'pinky'|'clyde')} name - The name of the current ghost\n   */ setDefaultPosition(scaledTileSize, name) {\n        switch(name){\n            case \"blinky\":\n                this.defaultPosition = {\n                    top: scaledTileSize * 10.5,\n                    left: scaledTileSize * 13\n                };\n                break;\n            case \"pinky\":\n                this.defaultPosition = {\n                    top: scaledTileSize * 13.5,\n                    left: scaledTileSize * 13\n                };\n                break;\n            case \"inky\":\n                this.defaultPosition = {\n                    top: scaledTileSize * 13.5,\n                    left: scaledTileSize * 11\n                };\n                break;\n            case \"clyde\":\n                this.defaultPosition = {\n                    top: scaledTileSize * 13.5,\n                    left: scaledTileSize * 15\n                };\n                break;\n            default:\n                this.defaultPosition = {\n                    top: 0,\n                    left: 0\n                };\n                break;\n        }\n        this.position = Object.assign({}, this.defaultPosition);\n        this.oldPosition = Object.assign({}, this.position);\n        this.animationTarget.style.top = `${this.position.top}px`;\n        this.animationTarget.style.left = `${this.position.left}px`;\n    }\n    /**\n   * Chooses a movement Spritesheet depending upon direction\n   * @param {('inky'|'blinky'|'pinky'|'clyde')} name - The name of the current ghost\n   * @param {('up'|'down'|'left'|'right')} direction - The character's current travel orientation\n   * @param {('chase'|'scatter'|'scared'|'eyes')} mode - The character's behavior mode\n   */ setSpriteSheet(name, direction, mode) {\n        let emotion = \"\";\n        if (this.defaultSpeed !== this.slowSpeed) emotion = this.defaultSpeed === this.mediumSpeed ? \"_annoyed\" : \"_angry\";\n        if (mode === \"scared\") this.animationTarget.style.backgroundImage = \"url(/style/graphics/\" + `spriteSheets/characters/ghosts/scared_${this.scaredColor}.svg)`;\n        else if (mode === \"eyes\") this.animationTarget.style.backgroundImage = \"url(/style/graphics/\" + `spriteSheets/characters/ghosts/eyes_${direction}.svg)`;\n        else this.animationTarget.style.backgroundImage = \"url(/style/graphics/\" + `spriteSheets/characters/ghosts/${name}/${name}_${direction}` + `${emotion}.svg)`;\n    }\n    /**\n   * Checks to see if the ghost is currently in the 'tunnels' on the outer edges of the maze\n   * @param {({x: number, y: number})} gridPosition - The current x-y position on the 2D Maze Array\n   * @returns {Boolean}\n   */ isInTunnel(gridPosition) {\n        return gridPosition.y === 14 && (gridPosition.x < 6 || gridPosition.x > 21);\n    }\n    /**\n   * Checks to see if the ghost is currently in the 'Ghost House' in the center of the maze\n   * @param {({x: number, y: number})} gridPosition - The current x-y position on the 2D Maze Array\n   * @returns {Boolean}\n   */ isInGhostHouse(gridPosition) {\n        return gridPosition.x > 9 && gridPosition.x < 18 && gridPosition.y > 11 && gridPosition.y < 17;\n    }\n    /**\n   * Checks to see if the tile at the given coordinates of the Maze is an open position\n   * @param {Array} mazeArray - 2D array representing the game board\n   * @param {number} y - The target row\n   * @param {number} x - The target column\n   * @returns {(false | { x: number, y: number})} - x-y pair if the tile is free, false otherwise\n   */ getTile(mazeArray, y, x) {\n        let tile = false;\n        if (mazeArray[y] && mazeArray[y][x] && mazeArray[y][x] !== \"X\") tile = {\n            x: x,\n            y: y\n        };\n        return tile;\n    }\n    /**\n   * Returns a list of all of the possible moves for the ghost to make on the next turn\n   * @param {({x: number, y: number})} gridPosition - The current x-y position on the 2D Maze Array\n   * @param {('up'|'down'|'left'|'right')} direction - The character's current travel orientation\n   * @param {Array} mazeArray - 2D array representing the game board\n   * @returns {object}\n   */ determinePossibleMoves(gridPosition, direction, mazeArray) {\n        const { x: x , y: y  } = gridPosition;\n        const possibleMoves = {\n            up: this.getTile(mazeArray, y - 1, x),\n            down: this.getTile(mazeArray, y + 1, x),\n            left: this.getTile(mazeArray, y, x - 1),\n            right: this.getTile(mazeArray, y, x + 1)\n        };\n        // Ghosts are not allowed to turn around at crossroads\n        possibleMoves[this.characterUtil.getOppositeDirection(direction)] = false;\n        Object.keys(possibleMoves).forEach((tile)=>{\n            if (possibleMoves[tile] === false) delete possibleMoves[tile];\n        });\n        return possibleMoves;\n    }\n    /**\n   * Uses the Pythagorean Theorem to measure the distance between a given postion and Pacman\n   * @param {({x: number, y: number})} position - An x-y position on the 2D Maze Array\n   * @param {({x: number, y: number})} pacman - Pacman's current x-y position on the 2D Maze Array\n   * @returns {number}\n   */ calculateDistance(position, pacman) {\n        return Math.sqrt((position.x - pacman.x) ** 2 + (position.y - pacman.y) ** 2);\n    }\n    /**\n   * Gets a position a number of spaces in front of Pacman's direction\n   * @param {({x: number, y: number})} pacmanGridPosition\n   * @param {number} spaces\n   */ getPositionInFrontOfPacman(pacmanGridPosition, spaces) {\n        const target = Object.assign({}, pacmanGridPosition);\n        const pacDirection = this.pacman.direction;\n        const propToChange = pacDirection === \"up\" || pacDirection === \"down\" ? \"y\" : \"x\";\n        const tileOffset = pacDirection === \"up\" || pacDirection === \"left\" ? spaces * -1 : spaces;\n        target[propToChange] += tileOffset;\n        return target;\n    }\n    /**\n   * Determines Pinky's target, which is four tiles in front of Pacman's direction\n   * @param {({x: number, y: number})} pacmanGridPosition\n   * @returns {({x: number, y: number})}\n   */ determinePinkyTarget(pacmanGridPosition) {\n        return this.getPositionInFrontOfPacman(pacmanGridPosition, 4);\n    }\n    /**\n   * Determines Inky's target, which is a mirror image of Blinky's position\n   * reflected across a point two tiles in front of Pacman's direction.\n   * Example @ app\\style\\graphics\\spriteSheets\\references\\inky_target.png\n   * @param {({x: number, y: number})} pacmanGridPosition\n   * @returns {({x: number, y: number})}\n   */ determineInkyTarget(pacmanGridPosition) {\n        const blinkyGridPosition = this.characterUtil.determineGridPosition(this.blinky.position, this.scaledTileSize);\n        const pivotPoint = this.getPositionInFrontOfPacman(pacmanGridPosition, 2);\n        return {\n            x: pivotPoint.x + (pivotPoint.x - blinkyGridPosition.x),\n            y: pivotPoint.y + (pivotPoint.y - blinkyGridPosition.y)\n        };\n    }\n    /**\n   * Clyde targets Pacman when the two are far apart, but retreats to the\n   * lower-left corner when the two are within eight tiles of each other\n   * @param {({x: number, y: number})} gridPosition\n   * @param {({x: number, y: number})} pacmanGridPosition\n   * @returns {({x: number, y: number})}\n   */ determineClydeTarget(gridPosition, pacmanGridPosition) {\n        const distance = this.calculateDistance(gridPosition, pacmanGridPosition);\n        return distance > 8 ? pacmanGridPosition : {\n            x: 0,\n            y: 30\n        };\n    }\n    /**\n   * Determines the appropriate target for the ghost's AI\n   * @param {('inky'|'blinky'|'pinky'|'clyde')} name - The name of the current ghost\n   * @param {({x: number, y: number})} gridPosition - The current x-y position on the 2D Maze Array\n   * @param {({x: number, y: number})} pacmanGridPosition - x-y position on the 2D Maze Array\n   * @param {('chase'|'scatter'|'scared'|'eyes')} mode - The character's behavior mode\n   * @returns {({x: number, y: number})}\n   */ getTarget(name, gridPosition, pacmanGridPosition, mode) {\n        // Ghosts return to the ghost-house after eaten\n        if (mode === \"eyes\") return {\n            x: 13.5,\n            y: 10\n        };\n        // Ghosts run from Pacman if scared\n        if (mode === \"scared\") return pacmanGridPosition;\n        // Ghosts seek out corners in Scatter mode\n        if (mode === \"scatter\") switch(name){\n            case \"blinky\":\n                // Blinky will chase Pacman, even in Scatter mode, if he's in Cruise Elroy form\n                return this.cruiseElroy ? pacmanGridPosition : {\n                    x: 27,\n                    y: 0\n                };\n            case \"pinky\":\n                return {\n                    x: 0,\n                    y: 0\n                };\n            case \"inky\":\n                return {\n                    x: 27,\n                    y: 30\n                };\n            case \"clyde\":\n                return {\n                    x: 0,\n                    y: 30\n                };\n            default:\n                return {\n                    x: 0,\n                    y: 0\n                };\n        }\n        switch(name){\n            // Blinky goes after Pacman's position\n            case \"blinky\":\n                return pacmanGridPosition;\n            case \"pinky\":\n                return this.determinePinkyTarget(pacmanGridPosition);\n            case \"inky\":\n                return this.determineInkyTarget(pacmanGridPosition);\n            case \"clyde\":\n                return this.determineClydeTarget(gridPosition, pacmanGridPosition);\n            default:\n                // TODO: Other ghosts\n                return pacmanGridPosition;\n        }\n    }\n    /**\n   * Calls the appropriate function to determine the best move depending on the ghost's name\n   * @param {('inky'|'blinky'|'pinky'|'clyde')} name - The name of the current ghost\n   * @param {Object} possibleMoves - All of the moves the ghost could choose to make this turn\n   * @param {({x: number, y: number})} gridPosition - The current x-y position on the 2D Maze Array\n   * @param {({x: number, y: number})} pacmanGridPosition - x-y position on the 2D Maze Array\n   * @param {('chase'|'scatter'|'scared'|'eyes')} mode - The character's behavior mode\n   * @returns {('up'|'down'|'left'|'right')}\n   */ determineBestMove(name, possibleMoves, gridPosition, pacmanGridPosition, mode) {\n        let bestDistance = mode === \"scared\" ? 0 : Infinity;\n        let bestMove;\n        const target = this.getTarget(name, gridPosition, pacmanGridPosition, mode);\n        Object.keys(possibleMoves).forEach((move)=>{\n            const distance = this.calculateDistance(possibleMoves[move], target);\n            const betterMove = mode === \"scared\" ? distance > bestDistance : distance < bestDistance;\n            if (betterMove) {\n                bestDistance = distance;\n                bestMove = move;\n            }\n        });\n        return bestMove;\n    }\n    /**\n   * Determines the best direction for the ghost to travel in during the current frame\n   * @param {('inky'|'blinky'|'pinky'|'clyde')} name - The name of the current ghost\n   * @param {({x: number, y: number})} gridPosition - The current x-y position on the 2D Maze Array\n   * @param {({x: number, y: number})} pacmanGridPosition - x-y position on the 2D Maze Array\n   * @param {('up'|'down'|'left'|'right')} direction - The character's current travel orientation\n   * @param {Array} mazeArray - 2D array representing the game board\n   * @param {('chase'|'scatter'|'scared'|'eyes')} mode - The character's behavior mode\n   * @returns {('up'|'down'|'left'|'right')}\n   */ determineDirection(name, gridPosition, pacmanGridPosition, direction, mazeArray, mode) {\n        let newDirection = direction;\n        const possibleMoves = this.determinePossibleMoves(gridPosition, direction, mazeArray);\n        if (Object.keys(possibleMoves).length === 1) [newDirection] = Object.keys(possibleMoves);\n        else if (Object.keys(possibleMoves).length > 1) newDirection = this.determineBestMove(name, possibleMoves, gridPosition, pacmanGridPosition, mode);\n        return newDirection;\n    }\n    /**\n   * Handles movement for idle Ghosts in the Ghost House\n   * @param {*} elapsedMs\n   * @param {*} position\n   * @param {*} velocity\n   * @returns {({ top: number, left: number})}\n   */ handleIdleMovement(elapsedMs, position, velocity) {\n        const newPosition = Object.assign({}, this.position);\n        if (position.y <= 13.5) this.direction = this.characterUtil.directions.down;\n        else if (position.y >= 14.5) this.direction = this.characterUtil.directions.up;\n        if (this.idleMode === \"leaving\") {\n            if (position.x === 13.5 && position.y > 10.8 && position.y < 11) {\n                this.idleMode = undefined;\n                newPosition.top = this.scaledTileSize * 10.5;\n                this.direction = this.characterUtil.directions.left;\n                window.dispatchEvent(new Event(\"releaseGhost\"));\n            } else if (position.x > 13.4 && position.x < 13.6) {\n                newPosition.left = this.scaledTileSize * 13;\n                this.direction = this.characterUtil.directions.up;\n            } else if (position.y > 13.9 && position.y < 14.1) {\n                newPosition.top = this.scaledTileSize * 13.5;\n                this.direction = position.x < 13.5 ? this.characterUtil.directions.right : this.characterUtil.directions.left;\n            }\n        }\n        newPosition[this.characterUtil.getPropertyToChange(this.direction)] += this.characterUtil.getVelocity(this.direction, velocity) * elapsedMs;\n        return newPosition;\n    }\n    /**\n   * Sets idleMode to 'leaving', allowing the ghost to leave the Ghost House\n   */ endIdleMode() {\n        this.idleMode = \"leaving\";\n    }\n    /**\n   * Handle the ghost's movement when it is snapped to the x-y grid of the Maze Array\n   * @param {number} elapsedMs - The amount of MS that have passed since the last update\n   * @param {({x: number, y: number})} gridPosition - x-y position during the current frame\n   * @param {number} velocity - The distance the character should travel in a single millisecond\n   * @param {({x: number, y: number})} pacmanGridPosition - x-y position on the 2D Maze Array\n   * @returns {({ top: number, left: number})}\n   */ handleSnappedMovement(elapsedMs, gridPosition, velocity, pacmanGridPosition) {\n        const newPosition = Object.assign({}, this.position);\n        this.direction = this.determineDirection(this.name, gridPosition, pacmanGridPosition, this.direction, this.mazeArray, this.mode);\n        newPosition[this.characterUtil.getPropertyToChange(this.direction)] += this.characterUtil.getVelocity(this.direction, velocity) * elapsedMs;\n        return newPosition;\n    }\n    /**\n   * Determines if an eaten ghost is at the entrance of the Ghost House\n   * @param {('chase'|'scatter'|'scared'|'eyes')} mode - The character's behavior mode\n   * @param {({x: number, y: number})} position - x-y position during the current frame\n   * @returns {Boolean}\n   */ enteringGhostHouse(mode, position) {\n        return mode === \"eyes\" && position.y === 11 && position.x > 13.4 && position.x < 13.6;\n    }\n    /**\n   * Determines if an eaten ghost has reached the center of the Ghost House\n   * @param {('chase'|'scatter'|'scared'|'eyes')} mode - The character's behavior mode\n   * @param {({x: number, y: number})} position - x-y position during the current frame\n   * @returns {Boolean}\n   */ enteredGhostHouse(mode, position) {\n        return mode === \"eyes\" && position.x === 13.5 && position.y > 13.8 && position.y < 14.2;\n    }\n    /**\n   * Determines if a restored ghost is at the exit of the Ghost House\n   * @param {('chase'|'scatter'|'scared'|'eyes')} mode - The character's behavior mode\n   * @param {({x: number, y: number})} position - x-y position during the current frame\n   * @returns {Boolean}\n   */ leavingGhostHouse(mode, position) {\n        return mode !== \"eyes\" && position.x === 13.5 && position.y > 10.8 && position.y < 11;\n    }\n    /**\n   * Handles entering and leaving the Ghost House after a ghost is eaten\n   * @param {({x: number, y: number})} gridPosition - x-y position during the current frame\n   * @returns {({x: number, y: number})}\n   */ handleGhostHouse(gridPosition) {\n        const gridPositionCopy = Object.assign({}, gridPosition);\n        if (this.enteringGhostHouse(this.mode, gridPosition)) {\n            this.direction = this.characterUtil.directions.down;\n            gridPositionCopy.x = 13.5;\n            this.position = this.characterUtil.snapToGrid(gridPositionCopy, this.direction, this.scaledTileSize);\n        }\n        if (this.enteredGhostHouse(this.mode, gridPosition)) {\n            this.direction = this.characterUtil.directions.up;\n            gridPositionCopy.y = 14;\n            this.position = this.characterUtil.snapToGrid(gridPositionCopy, this.direction, this.scaledTileSize);\n            this.mode = this.defaultMode;\n            window.dispatchEvent(new Event(\"restoreGhost\"));\n        }\n        if (this.leavingGhostHouse(this.mode, gridPosition)) {\n            gridPositionCopy.y = 11;\n            this.position = this.characterUtil.snapToGrid(gridPositionCopy, this.direction, this.scaledTileSize);\n            this.direction = this.characterUtil.directions.left;\n        }\n        return gridPositionCopy;\n    }\n    /**\n   * Handle the ghost's movement when it is inbetween tiles on the x-y grid of the Maze Array\n   * @param {number} elapsedMs - The amount of MS that have passed since the last update\n   * @param {({x: number, y: number})} gridPosition - x-y position during the current frame\n   * @param {number} velocity - The distance the character should travel in a single millisecond\n   * @returns {({ top: number, left: number})}\n   */ handleUnsnappedMovement(elapsedMs, gridPosition, velocity) {\n        const gridPositionCopy = this.handleGhostHouse(gridPosition);\n        const desired = this.characterUtil.determineNewPositions(this.position, this.direction, velocity, elapsedMs, this.scaledTileSize);\n        if (this.characterUtil.changingGridPosition(gridPositionCopy, desired.newGridPosition)) return this.characterUtil.snapToGrid(gridPositionCopy, this.direction, this.scaledTileSize);\n        return desired.newPosition;\n    }\n    /**\n   * Determines the new Ghost position\n   * @param {number} elapsedMs\n   * @returns {({ top: number, left: number})}\n   */ handleMovement(elapsedMs) {\n        let newPosition;\n        const gridPosition = this.characterUtil.determineGridPosition(this.position, this.scaledTileSize);\n        const pacmanGridPosition = this.characterUtil.determineGridPosition(this.pacman.position, this.scaledTileSize);\n        const velocity = this.determineVelocity(gridPosition, this.mode);\n        if (this.idleMode) newPosition = this.handleIdleMovement(elapsedMs, gridPosition, velocity);\n        else if (JSON.stringify(this.position) === JSON.stringify(this.characterUtil.snapToGrid(gridPosition, this.direction, this.scaledTileSize))) newPosition = this.handleSnappedMovement(elapsedMs, gridPosition, velocity, pacmanGridPosition);\n        else newPosition = this.handleUnsnappedMovement(elapsedMs, gridPosition, velocity);\n        newPosition = this.characterUtil.handleWarp(newPosition, this.scaledTileSize, this.mazeArray);\n        this.checkCollision(gridPosition, pacmanGridPosition);\n        return newPosition;\n    }\n    /**\n   * Changes the defaultMode to chase or scatter, and turns the ghost around\n   * if needed\n   * @param {('chase'|'scatter')} newMode\n   */ changeMode(newMode) {\n        this.defaultMode = newMode;\n        const gridPosition = this.characterUtil.determineGridPosition(this.position, this.scaledTileSize);\n        if ((this.mode === \"chase\" || this.mode === \"scatter\") && !this.cruiseElroy) {\n            this.mode = newMode;\n            if (!this.isInGhostHouse(gridPosition)) this.direction = this.characterUtil.getOppositeDirection(this.direction);\n        }\n    }\n    /**\n   * Toggles a scared ghost between blue and white, then updates its spritsheet\n   */ toggleScaredColor() {\n        this.scaredColor = this.scaredColor === \"blue\" ? \"white\" : \"blue\";\n        this.setSpriteSheet(this.name, this.direction, this.mode);\n    }\n    /**\n   * Sets the ghost's mode to SCARED, turns the ghost around,\n   * and changes spritesheets accordingly\n   */ becomeScared() {\n        const gridPosition = this.characterUtil.determineGridPosition(this.position, this.scaledTileSize);\n        if (this.mode !== \"eyes\") {\n            if (!this.isInGhostHouse(gridPosition) && this.mode !== \"scared\") this.direction = this.characterUtil.getOppositeDirection(this.direction);\n            this.mode = \"scared\";\n            this.scaredColor = \"blue\";\n            this.setSpriteSheet(this.name, this.direction, this.mode);\n        }\n    }\n    /**\n   * Returns the scared ghost to chase/scatter mode and sets its spritesheet\n   */ endScared() {\n        this.mode = this.defaultMode;\n        this.setSpriteSheet(this.name, this.direction, this.mode);\n    }\n    /**\n   * Speeds up the ghost (used for Blinky as Pacdots are eaten)\n   */ speedUp() {\n        this.cruiseElroy = true;\n        if (this.defaultSpeed === this.slowSpeed) this.defaultSpeed = this.mediumSpeed;\n        else if (this.defaultSpeed === this.mediumSpeed) this.defaultSpeed = this.fastSpeed;\n    }\n    /**\n   * Resets defaultSpeed to slow and updates the spritesheet\n   */ resetDefaultSpeed() {\n        this.defaultSpeed = this.slowSpeed;\n        this.cruiseElroy = false;\n        this.setSpriteSheet(this.name, this.direction, this.mode);\n    }\n    /**\n   * Sets a flag to indicate when the ghost should pause its movement\n   * @param {Boolean} newValue\n   */ pause(newValue) {\n        this.paused = newValue;\n    }\n    /**\n   * Checks if the ghost contacts Pacman - starts the death sequence if so\n   * @param {({x: number, y: number})} position - An x-y position on the 2D Maze Array\n   * @param {({x: number, y: number})} pacman - Pacman's current x-y position on the 2D Maze Array\n   */ checkCollision(position, pacman) {\n        if (this.calculateDistance(position, pacman) < 1 && this.mode !== \"eyes\" && this.allowCollision) {\n            if (this.mode === \"scared\") {\n                window.dispatchEvent(new CustomEvent(\"eatGhost\", {\n                    detail: {\n                        ghost: this\n                    }\n                }));\n                this.mode = \"eyes\";\n            } else window.dispatchEvent(new Event(\"deathSequence\"));\n        }\n    }\n    /**\n   * Determines the appropriate speed for the ghost\n   * @param {({x: number, y: number})} position - An x-y position on the 2D Maze Array\n   * @param {('chase'|'scatter'|'scared'|'eyes')} mode - The character's behavior mode\n   * @returns {number}\n   */ determineVelocity(position, mode) {\n        if (mode === \"eyes\") return this.eyeSpeed;\n        if (this.paused) return 0;\n        if (this.isInTunnel(position) || this.isInGhostHouse(position)) return this.transitionSpeed;\n        if (mode === \"scared\") return this.scaredSpeed;\n        return this.defaultSpeed;\n    }\n    /**\n   * Updates the css position, hides if there is a stutter, and animates the spritesheet\n   * @param {number} interp - The animation accuracy as a percentage\n   */ draw(interp) {\n        const newTop = this.characterUtil.calculateNewDrawValue(interp, \"top\", this.oldPosition, this.position);\n        const newLeft = this.characterUtil.calculateNewDrawValue(interp, \"left\", this.oldPosition, this.position);\n        this.animationTarget.style.top = `${newTop}px`;\n        this.animationTarget.style.left = `${newLeft}px`;\n        this.animationTarget.style.visibility = this.display ? this.characterUtil.checkForStutter(this.position, this.oldPosition) : \"hidden\";\n        const updatedProperties = this.characterUtil.advanceSpriteSheet(this);\n        this.msSinceLastSprite = updatedProperties.msSinceLastSprite;\n        this.animationTarget = updatedProperties.animationTarget;\n        this.backgroundOffsetPixels = updatedProperties.backgroundOffsetPixels;\n    }\n    /**\n   * Handles movement logic for the ghost\n   * @param {number} elapsedMs - The amount of MS that have passed since the last update\n   */ update(elapsedMs) {\n        this.oldPosition = Object.assign({}, this.position);\n        if (this.moving) {\n            this.position = this.handleMovement(elapsedMs);\n            this.setSpriteSheet(this.name, this.direction, this.mode);\n            this.msSinceLastSprite += elapsedMs;\n        }\n    }\n}\nclass $7fc2474486b8416c$var$Pacman {\n    constructor(scaledTileSize, mazeArray, characterUtil){\n        this.scaledTileSize = scaledTileSize;\n        this.mazeArray = mazeArray;\n        this.characterUtil = characterUtil;\n        this.animationTarget = document.getElementById(\"pacman\");\n        this.pacmanArrow = document.getElementById(\"pacman-arrow\");\n        this.reset();\n    }\n    /**\n   * Rests the character to its default state\n   */ reset() {\n        this.setMovementStats(this.scaledTileSize);\n        this.setSpriteAnimationStats();\n        this.setStyleMeasurements(this.scaledTileSize, this.spriteFrames);\n        this.setDefaultPosition(this.scaledTileSize);\n        this.setSpriteSheet(this.direction);\n        this.pacmanArrow.style.backgroundImage = \"url(/style/graphics/\" + `spriteSheets/characters/pacman/arrow_${this.direction}.svg)`;\n    }\n    /**\n   * Sets various properties related to Pacman's movement\n   * @param {number} scaledTileSize - The dimensions of a single tile\n   */ setMovementStats(scaledTileSize) {\n        this.velocityPerMs = this.calculateVelocityPerMs(scaledTileSize);\n        this.desiredDirection = this.characterUtil.directions.left;\n        this.direction = this.characterUtil.directions.left;\n        this.moving = false;\n    }\n    /**\n   * Sets values pertaining to Pacman's spritesheet animation\n   */ setSpriteAnimationStats() {\n        this.specialAnimation = false;\n        this.display = true;\n        this.animate = true;\n        this.loopAnimation = true;\n        this.msBetweenSprites = 50;\n        this.msSinceLastSprite = 0;\n        this.spriteFrames = 4;\n        this.backgroundOffsetPixels = 0;\n        this.animationTarget.style.backgroundPosition = \"0px 0px\";\n    }\n    /**\n   * Sets css property values for Pacman and Pacman's Arrow\n   * @param {number} scaledTileSize - The dimensions of a single tile\n   * @param {number} spriteFrames - The number of frames in Pacman's spritesheet\n   */ setStyleMeasurements(scaledTileSize, spriteFrames) {\n        this.measurement = scaledTileSize * 2;\n        this.animationTarget.style.height = `${this.measurement}px`;\n        this.animationTarget.style.width = `${this.measurement}px`;\n        this.animationTarget.style.backgroundSize = `${this.measurement * spriteFrames}px`;\n        this.pacmanArrow.style.height = `${this.measurement * 2}px`;\n        this.pacmanArrow.style.width = `${this.measurement * 2}px`;\n        this.pacmanArrow.style.backgroundSize = `${this.measurement * 2}px`;\n    }\n    /**\n   * Sets the default position and direction for Pacman at the game's start\n   * @param {number} scaledTileSize - The dimensions of a single tile\n   */ setDefaultPosition(scaledTileSize) {\n        this.defaultPosition = {\n            top: scaledTileSize * 22.5,\n            left: scaledTileSize * 13\n        };\n        this.position = Object.assign({}, this.defaultPosition);\n        this.oldPosition = Object.assign({}, this.position);\n        this.animationTarget.style.top = `${this.position.top}px`;\n        this.animationTarget.style.left = `${this.position.left}px`;\n    }\n    /**\n   * Calculates how fast Pacman should move in a millisecond\n   * @param {number} scaledTileSize - The dimensions of a single tile\n   */ calculateVelocityPerMs(scaledTileSize) {\n        // In the original game, Pacman moved at 11 tiles per second.\n        const velocityPerSecond = scaledTileSize * 11;\n        return velocityPerSecond / 1000;\n    }\n    /**\n   * Chooses a movement Spritesheet depending upon direction\n   * @param {('up'|'down'|'left'|'right')} direction - The character's current travel orientation\n   */ setSpriteSheet(direction) {\n        this.animationTarget.style.backgroundImage = \"url(/style/graphics/\" + `spriteSheets/characters/pacman/pacman_${direction}.svg)`;\n    }\n    prepDeathAnimation() {\n        this.loopAnimation = false;\n        this.msBetweenSprites = 125;\n        this.spriteFrames = 12;\n        this.specialAnimation = true;\n        this.backgroundOffsetPixels = 0;\n        const bgSize = this.measurement * this.spriteFrames;\n        this.animationTarget.style.backgroundSize = `${bgSize}px`;\n        this.animationTarget.style.backgroundImage = \"url(/style/graphics/spriteSheets/characters/pacman/pacman_death.svg)\";\n        this.animationTarget.style.backgroundPosition = \"0px 0px\";\n        this.pacmanArrow.style.backgroundImage = \"\";\n    }\n    /**\n   * Changes Pacman's desiredDirection, updates the PacmanArrow sprite, and sets moving to true\n   * @param {Event} e - The keydown event to evaluate\n   * @param {Boolean} startMoving - If true, Pacman will move upon key press\n   */ changeDirection(newDirection, startMoving) {\n        this.desiredDirection = newDirection;\n        this.pacmanArrow.style.backgroundImage = \"url(/style/graphics/\" + `spriteSheets/characters/pacman/arrow_${this.desiredDirection}.svg)`;\n        if (startMoving) this.moving = true;\n    }\n    /**\n   * Updates the position of the leading arrow in front of Pacman\n   * @param {({top: number, left: number})} position - Pacman's position during the current frame\n   * @param {number} scaledTileSize - The dimensions of a single tile\n   */ updatePacmanArrowPosition(position, scaledTileSize) {\n        this.pacmanArrow.style.top = `${position.top - scaledTileSize}px`;\n        this.pacmanArrow.style.left = `${position.left - scaledTileSize}px`;\n    }\n    /**\n   * Handle Pacman's movement when he is snapped to the x-y grid of the Maze Array\n   * @param {number} elapsedMs - The amount of MS that have passed since the last update\n   * @returns {({ top: number, left: number})}\n   */ handleSnappedMovement(elapsedMs) {\n        const desired = this.characterUtil.determineNewPositions(this.position, this.desiredDirection, this.velocityPerMs, elapsedMs, this.scaledTileSize);\n        const alternate = this.characterUtil.determineNewPositions(this.position, this.direction, this.velocityPerMs, elapsedMs, this.scaledTileSize);\n        if (this.characterUtil.checkForWallCollision(desired.newGridPosition, this.mazeArray, this.desiredDirection)) {\n            if (this.characterUtil.checkForWallCollision(alternate.newGridPosition, this.mazeArray, this.direction)) {\n                this.moving = false;\n                return this.position;\n            }\n            return alternate.newPosition;\n        }\n        this.direction = this.desiredDirection;\n        this.setSpriteSheet(this.direction);\n        return desired.newPosition;\n    }\n    /**\n   * Handle Pacman's movement when he is inbetween tiles on the x-y grid of the Maze Array\n   * @param {({x: number, y: number})} gridPosition - x-y position during the current frame\n   * @param {number} elapsedMs - The amount of MS that have passed since the last update\n   * @returns {({ top: number, left: number})}\n   */ handleUnsnappedMovement(gridPosition, elapsedMs) {\n        const desired = this.characterUtil.determineNewPositions(this.position, this.desiredDirection, this.velocityPerMs, elapsedMs, this.scaledTileSize);\n        const alternate = this.characterUtil.determineNewPositions(this.position, this.direction, this.velocityPerMs, elapsedMs, this.scaledTileSize);\n        if (this.characterUtil.turningAround(this.direction, this.desiredDirection)) {\n            this.direction = this.desiredDirection;\n            this.setSpriteSheet(this.direction);\n            return desired.newPosition;\n        }\n        if (this.characterUtil.changingGridPosition(gridPosition, alternate.newGridPosition)) return this.characterUtil.snapToGrid(gridPosition, this.direction, this.scaledTileSize);\n        return alternate.newPosition;\n    }\n    /**\n   * Updates the css position, hides if there is a stutter, and animates the spritesheet\n   * @param {number} interp - The animation accuracy as a percentage\n   */ draw(interp) {\n        const newTop = this.characterUtil.calculateNewDrawValue(interp, \"top\", this.oldPosition, this.position);\n        const newLeft = this.characterUtil.calculateNewDrawValue(interp, \"left\", this.oldPosition, this.position);\n        this.animationTarget.style.top = `${newTop}px`;\n        this.animationTarget.style.left = `${newLeft}px`;\n        this.animationTarget.style.visibility = this.display ? this.characterUtil.checkForStutter(this.position, this.oldPosition) : \"hidden\";\n        this.pacmanArrow.style.visibility = this.animationTarget.style.visibility;\n        this.updatePacmanArrowPosition(this.position, this.scaledTileSize);\n        const updatedProperties = this.characterUtil.advanceSpriteSheet(this);\n        this.msSinceLastSprite = updatedProperties.msSinceLastSprite;\n        this.animationTarget = updatedProperties.animationTarget;\n        this.backgroundOffsetPixels = updatedProperties.backgroundOffsetPixels;\n    }\n    /**\n   * Handles movement logic for Pacman\n   * @param {number} elapsedMs - The amount of MS that have passed since the last update\n   */ update(elapsedMs) {\n        this.oldPosition = Object.assign({}, this.position);\n        if (this.moving) {\n            const gridPosition = this.characterUtil.determineGridPosition(this.position, this.scaledTileSize);\n            if (JSON.stringify(this.position) === JSON.stringify(this.characterUtil.snapToGrid(gridPosition, this.direction, this.scaledTileSize))) this.position = this.handleSnappedMovement(elapsedMs);\n            else this.position = this.handleUnsnappedMovement(gridPosition, elapsedMs);\n            this.position = this.characterUtil.handleWarp(this.position, this.scaledTileSize, this.mazeArray);\n        }\n        if (this.moving || this.specialAnimation) this.msSinceLastSprite += elapsedMs;\n    }\n}\nclass $7fc2474486b8416c$export$fb4646ab13eb7425 {\n    constructor(){\n        this.gameUi = document.getElementById(\"game-ui\");\n        this.rowTop = document.getElementById(\"row-top\");\n        this.mazeDiv = document.getElementById(\"maze\");\n        this.mazeImg = document.getElementById(\"maze-img\");\n        this.mazeCover = document.getElementById(\"maze-cover\");\n        this.pointsDisplay = document.getElementById(\"points-display\");\n        this.highScoreDisplay = document.getElementById(\"high-score-display\");\n        this.extraLivesDisplay = document.getElementById(\"extra-lives\");\n        this.fruitDisplay = document.getElementById(\"fruit-display\");\n        this.mainMenu = document.getElementById(\"main-menu-container\");\n        this.gameStartButton = document.getElementById(\"game-start\");\n        this.pauseButton = document.getElementById(\"pause-button\");\n        this.soundButton = document.getElementById(\"sound-button\");\n        this.leftCover = document.getElementById(\"left-cover\");\n        this.rightCover = document.getElementById(\"right-cover\");\n        this.pausedText = document.getElementById(\"paused-text\");\n        this.bottomRow = document.getElementById(\"bottom-row\");\n        this.movementButtons = document.getElementById(\"movement-buttons\");\n        this.mazeArray = [\n            [\n                \"XXXXXXXXXXXXXXXXXXXXXXXXXXXX\"\n            ],\n            [\n                \"XooooooooooooXXooooooooooooX\"\n            ],\n            [\n                \"XoXXXXoXXXXXoXXoXXXXXoXXXXoX\"\n            ],\n            [\n                \"XOXXXXoXXXXXoXXoXXXXXoXXXXOX\"\n            ],\n            [\n                \"XoXXXXoXXXXXoXXoXXXXXoXXXXoX\"\n            ],\n            [\n                \"XooooooooooooooooooooooooooX\"\n            ],\n            [\n                \"XoXXXXoXXoXXXXXXXXoXXoXXXXoX\"\n            ],\n            [\n                \"XoXXXXoXXoXXXXXXXXoXXoXXXXoX\"\n            ],\n            [\n                \"XooooooXXooooXXooooXXooooooX\"\n            ],\n            [\n                \"XXXXXXoXXXXX XX XXXXXoXXXXXX\"\n            ],\n            [\n                \"XXXXXXoXXXXX XX XXXXXoXXXXXX\"\n            ],\n            [\n                \"XXXXXXoXX          XXoXXXXXX\"\n            ],\n            [\n                \"XXXXXXoXX XXXXXXXX XXoXXXXXX\"\n            ],\n            [\n                \"XXXXXXoXX X      X XXoXXXXXX\"\n            ],\n            [\n                \"      o   X      X   o      \"\n            ],\n            [\n                \"XXXXXXoXX X      X XXoXXXXXX\"\n            ],\n            [\n                \"XXXXXXoXX XXXXXXXX XXoXXXXXX\"\n            ],\n            [\n                \"XXXXXXoXX          XXoXXXXXX\"\n            ],\n            [\n                \"XXXXXXoXX XXXXXXXX XXoXXXXXX\"\n            ],\n            [\n                \"XXXXXXoXX XXXXXXXX XXoXXXXXX\"\n            ],\n            [\n                \"XooooooooooooXXooooooooooooX\"\n            ],\n            [\n                \"XoXXXXoXXXXXoXXoXXXXXoXXXXoX\"\n            ],\n            [\n                \"XoXXXXoXXXXXoXXoXXXXXoXXXXoX\"\n            ],\n            [\n                \"XOooXXooooooo  oooooooXXooOX\"\n            ],\n            [\n                \"XXXoXXoXXoXXXXXXXXoXXoXXoXXX\"\n            ],\n            [\n                \"XXXoXXoXXoXXXXXXXXoXXoXXoXXX\"\n            ],\n            [\n                \"XooooooXXooooXXooooXXooooooX\"\n            ],\n            [\n                \"XoXXXXXXXXXXoXXoXXXXXXXXXXoX\"\n            ],\n            [\n                \"XoXXXXXXXXXXoXXoXXXXXXXXXXoX\"\n            ],\n            [\n                \"XooooooooooooooooooooooooooX\"\n            ],\n            [\n                \"XXXXXXXXXXXXXXXXXXXXXXXXXXXX\"\n            ]\n        ];\n        this.maxFps = 120;\n        this.tileSize = 8;\n        this.scale = this.determineScale(1);\n        this.scaledTileSize = this.tileSize * this.scale;\n        this.firstGame = true;\n        this.movementKeys = {\n            // WASD\n            87: \"up\",\n            83: \"down\",\n            65: \"left\",\n            68: \"right\",\n            // Arrow Keys\n            38: \"up\",\n            40: \"down\",\n            37: \"left\",\n            39: \"right\"\n        };\n        this.fruitPoints = {\n            1: 100,\n            2: 300,\n            3: 500,\n            4: 700,\n            5: 1000,\n            6: 2000,\n            7: 3000,\n            8: 5000\n        };\n        this.mazeArray.forEach((row, rowIndex)=>{\n            this.mazeArray[rowIndex] = row[0].split(\"\");\n        });\n        this.gameStartButton.addEventListener(\"click\", this.startButtonClick.bind(this));\n        this.pauseButton.addEventListener(\"click\", this.handlePauseKey.bind(this));\n        this.soundButton.addEventListener(\"click\", this.soundButtonClick.bind(this));\n        setTimeout(()=>{\n            this.preloadAssets();\n        }, 100);\n    }\n    /**\n   * Recursive method which determines the largest possible scale the game's graphics can use\n   * @param {Number} scale\n   */ determineScale(scale) {\n        const availableScreenHeight = Math.min(document.documentElement.clientHeight, window.innerHeight || 0);\n        const availableScreenWidth = Math.min(document.documentElement.clientWidth, window.innerWidth || 0);\n        const scaledTileSize = this.tileSize * scale;\n        // The original Pac-Man game leaves 5 tiles of height (3 above, 2 below) surrounding the\n        // maze for the UI. See app\\style\\graphics\\spriteSheets\\references\\mazeGridSystemReference.png\n        // for reference.\n        const mazeTileHeight = this.mazeArray.length + 5;\n        const mazeTileWidth = this.mazeArray[0][0].split(\"\").length;\n        if (scaledTileSize * mazeTileHeight < availableScreenHeight && scaledTileSize * mazeTileWidth < availableScreenWidth) return this.determineScale(scale + 1);\n        return scale - 1;\n    }\n    /**\n   * Reveals the game underneath the loading covers and starts gameplay\n   */ startButtonClick() {\n        console.log(\"clicked\") // TODO: add execute smart contract here....\n        ;\n        this.leftCover.style.left = \"-50%\";\n        this.rightCover.style.right = \"-50%\";\n        this.mainMenu.style.opacity = 0;\n        this.gameStartButton.disabled = true;\n        setTimeout(()=>{\n            this.mainMenu.style.visibility = \"hidden\";\n        }, 1000);\n        this.reset();\n        if (this.firstGame) {\n            this.firstGame = false;\n            this.init();\n        }\n        this.startGameplay(true);\n    }\n    /**\n   * Toggles the master volume for the soundManager, and saves the preference to storage\n   */ soundButtonClick() {\n        const newVolume = this.soundManager.masterVolume === 1 ? 0 : 1;\n        this.soundManager.setMasterVolume(newVolume);\n        localStorage.setItem(\"volumePreference\", newVolume);\n        this.setSoundButtonIcon(newVolume);\n    }\n    /**\n   * Sets the icon for the sound button\n   */ setSoundButtonIcon(newVolume) {\n        this.soundButton.innerHTML = newVolume === 0 ? \"volume_off\" : \"volume_up\";\n    }\n    /**\n   * Displays an error message in the event assets are unable to download\n   */ displayErrorMessage() {\n        console.log(\"display error message\");\n        const loadingContainer = document.getElementById(\"loading-container\");\n        const errorMessage = document.getElementById(\"error-message\");\n        loadingContainer.style.opacity = 0;\n        setTimeout(()=>{\n            loadingContainer.remove();\n            errorMessage.style.opacity = 1;\n            errorMessage.style.visibility = \"visible\";\n        }, 1500);\n    }\n    /**\n   * Load all assets into a hidden Div to pre-load them into memory.\n   * There is probably a better way to read all of these file names.\n   */ preloadAssets() {\n        console.log(\"preload assets...\");\n        return new Promise((resolve)=>{\n            const loadingContainer = document.getElementById(\"loading-container\");\n            const loadingPacman = document.getElementById(\"loading-pacman\");\n            const loadingDotMask = document.getElementById(\"loading-dot-mask\");\n            const imgBase = \"/style/graphics/spriteSheets/\";\n            const imgSources = [\n                // Pacman\n                `${imgBase}characters/pacman/arrow_down.svg`,\n                `${imgBase}characters/pacman/arrow_left.svg`,\n                `${imgBase}characters/pacman/arrow_right.svg`,\n                `${imgBase}characters/pacman/arrow_up.svg`,\n                `${imgBase}characters/pacman/pacman_death.svg`,\n                `${imgBase}characters/pacman/pacman_error.svg`,\n                `${imgBase}characters/pacman/pacman_down.svg`,\n                `${imgBase}characters/pacman/pacman_left.svg`,\n                `${imgBase}characters/pacman/pacman_right.svg`,\n                `${imgBase}characters/pacman/pacman_up.svg`,\n                // Blinky\n                `${imgBase}characters/ghosts/blinky/blinky_down_angry.svg`,\n                `${imgBase}characters/ghosts/blinky/blinky_down_annoyed.svg`,\n                `${imgBase}characters/ghosts/blinky/blinky_down.svg`,\n                `${imgBase}characters/ghosts/blinky/blinky_left_angry.svg`,\n                `${imgBase}characters/ghosts/blinky/blinky_left_annoyed.svg`,\n                `${imgBase}characters/ghosts/blinky/blinky_left.svg`,\n                `${imgBase}characters/ghosts/blinky/blinky_right_angry.svg`,\n                `${imgBase}characters/ghosts/blinky/blinky_right_annoyed.svg`,\n                `${imgBase}characters/ghosts/blinky/blinky_right.svg`,\n                `${imgBase}characters/ghosts/blinky/blinky_up_angry.svg`,\n                `${imgBase}characters/ghosts/blinky/blinky_up_annoyed.svg`,\n                `${imgBase}characters/ghosts/blinky/blinky_up.svg`,\n                // Clyde\n                `${imgBase}characters/ghosts/clyde/clyde_down.svg`,\n                `${imgBase}characters/ghosts/clyde/clyde_left.svg`,\n                `${imgBase}characters/ghosts/clyde/clyde_right.svg`,\n                `${imgBase}characters/ghosts/clyde/clyde_up.svg`,\n                // Inky\n                `${imgBase}characters/ghosts/inky/inky_down.svg`,\n                `${imgBase}characters/ghosts/inky/inky_left.svg`,\n                `${imgBase}characters/ghosts/inky/inky_right.svg`,\n                `${imgBase}characters/ghosts/inky/inky_up.svg`,\n                // Pinky\n                `${imgBase}characters/ghosts/pinky/pinky_down.svg`,\n                `${imgBase}characters/ghosts/pinky/pinky_left.svg`,\n                `${imgBase}characters/ghosts/pinky/pinky_right.svg`,\n                `${imgBase}characters/ghosts/pinky/pinky_up.svg`,\n                // Ghosts Common\n                `${imgBase}characters/ghosts/eyes_down.svg`,\n                `${imgBase}characters/ghosts/eyes_left.svg`,\n                `${imgBase}characters/ghosts/eyes_right.svg`,\n                `${imgBase}characters/ghosts/eyes_up.svg`,\n                `${imgBase}characters/ghosts/scared_blue.svg`,\n                `${imgBase}characters/ghosts/scared_white.svg`,\n                // Dots\n                `${imgBase}pickups/pacdot.svg`,\n                `${imgBase}pickups/powerPellet.svg`,\n                // Fruit\n                `${imgBase}pickups/apple.svg`,\n                `${imgBase}pickups/bell.svg`,\n                `${imgBase}pickups/cherry.svg`,\n                `${imgBase}pickups/galaxian.svg`,\n                `${imgBase}pickups/key.svg`,\n                `${imgBase}pickups/melon.svg`,\n                `${imgBase}pickups/orange.svg`,\n                `${imgBase}pickups/strawberry.svg`,\n                // Text\n                `${imgBase}text/ready.svg`,\n                // Points\n                `${imgBase}text/100.svg`,\n                `${imgBase}text/200.svg`,\n                `${imgBase}text/300.svg`,\n                `${imgBase}text/400.svg`,\n                `${imgBase}text/500.svg`,\n                `${imgBase}text/700.svg`,\n                `${imgBase}text/800.svg`,\n                `${imgBase}text/1000.svg`,\n                `${imgBase}text/1600.svg`,\n                `${imgBase}text/2000.svg`,\n                `${imgBase}text/3000.svg`,\n                `${imgBase}text/5000.svg`,\n                // Maze\n                `${imgBase}maze/maze_blue.svg`,\n                // Misc\n                \"/style/graphics/extra_life.png\"\n            ];\n            const audioBase = \"/style/audio/\";\n            const audioSources = [\n                `${audioBase}game_start.mp3`,\n                `${audioBase}pause.mp3`,\n                `${audioBase}pause_beat.mp3`,\n                `${audioBase}siren_1.mp3`,\n                `${audioBase}siren_2.mp3`,\n                `${audioBase}siren_3.mp3`,\n                `${audioBase}power_up.mp3`,\n                `${audioBase}extra_life.mp3`,\n                `${audioBase}eyes.mp3`,\n                `${audioBase}eat_ghost.mp3`,\n                `${audioBase}death.mp3`,\n                `${audioBase}fruit.mp3`,\n                `${audioBase}dot_1.mp3`,\n                `${audioBase}dot_2.mp3`\n            ];\n            const totalSources = imgSources.length + audioSources.length;\n            this.remainingSources = totalSources;\n            loadingPacman.style.left = \"0\";\n            loadingDotMask.style.width = \"0\";\n            Promise.all([\n                this.createElements(imgSources, \"img\", totalSources, this),\n                this.createElements(audioSources, \"audio\", totalSources, this)\n            ]).then(()=>{\n                loadingContainer.style.opacity = 0;\n                resolve();\n                setTimeout(()=>{\n                    loadingContainer.remove();\n                    this.mainMenu.style.opacity = 1;\n                    this.mainMenu.style.visibility = \"visible\";\n                }, 1500);\n            }).catch((e)=>{\n                console.log(\"load error:\", e);\n                this.displayErrorMessage();\n            });\n        });\n    }\n    /**\n   * Iterates through a list of sources and updates the loading bar as the assets load in\n   * @param {String[]} sources\n   * @param {('img'|'audio')} type\n   * @param {Number} totalSources\n   * @param {Object} gameCoord\n   * @returns {Promise}\n   */ createElements(sources, type, totalSources, gameCoord) {\n        const loadingContainer = document.getElementById(\"loading-container\");\n        const preloadDiv = document.getElementById(\"preload-div\");\n        const loadingPacman = document.getElementById(\"loading-pacman\");\n        const containerWidth = loadingContainer.scrollWidth - loadingPacman.scrollWidth;\n        const loadingDotMask = document.getElementById(\"loading-dot-mask\");\n        const gameCoordRef = gameCoord;\n        return new Promise((resolve, reject)=>{\n            let loadedSources = 0;\n            sources.forEach((source)=>{\n                const element = type === \"img\" ? new Image() : new Audio();\n                preloadDiv.appendChild(element);\n                const elementReady = ()=>{\n                    gameCoordRef.remainingSources -= 1;\n                    loadedSources += 1;\n                    const percent = 1 - gameCoordRef.remainingSources / totalSources;\n                    loadingPacman.style.left = `${percent * containerWidth}px`;\n                    loadingDotMask.style.width = loadingPacman.style.left;\n                    if (loadedSources === sources.length) resolve();\n                };\n                if (type === \"img\") {\n                    element.onload = elementReady;\n                    element.onerror = reject;\n                } else {\n                    element.addEventListener(\"canplaythrough\", elementReady);\n                    element.onerror = reject;\n                }\n                element.src = source;\n                if (type === \"audio\") element.load();\n            });\n        });\n    }\n    /**\n   * Resets gameCoordinator values to their default states\n   */ reset() {\n        this.activeTimers = [];\n        this.points = 0;\n        this.level = 1;\n        this.lives = 2;\n        this.extraLifeGiven = false;\n        this.remainingDots = 0;\n        this.allowKeyPresses = true;\n        this.allowPacmanMovement = false;\n        this.allowPause = false;\n        this.cutscene = true;\n        this.highScore = localStorage.getItem(\"highScore\");\n        if (this.firstGame) {\n            setInterval(()=>{\n                this.collisionDetectionLoop();\n            }, 500);\n            this.pacman = new $7fc2474486b8416c$var$Pacman(this.scaledTileSize, this.mazeArray, new $7fc2474486b8416c$var$CharacterUtil());\n            this.blinky = new $7fc2474486b8416c$var$Ghost(this.scaledTileSize, this.mazeArray, this.pacman, \"blinky\", this.level, new $7fc2474486b8416c$var$CharacterUtil());\n            this.pinky = new $7fc2474486b8416c$var$Ghost(this.scaledTileSize, this.mazeArray, this.pacman, \"pinky\", this.level, new $7fc2474486b8416c$var$CharacterUtil());\n            this.inky = new $7fc2474486b8416c$var$Ghost(this.scaledTileSize, this.mazeArray, this.pacman, \"inky\", this.level, new $7fc2474486b8416c$var$CharacterUtil(), this.blinky);\n            this.clyde = new $7fc2474486b8416c$var$Ghost(this.scaledTileSize, this.mazeArray, this.pacman, \"clyde\", this.level, new $7fc2474486b8416c$var$CharacterUtil());\n            this.fruit = new $7fc2474486b8416c$var$Pickup(\"fruit\", this.scaledTileSize, 13.5, 17, this.pacman, this.mazeDiv, 100);\n        }\n        this.entityList = [\n            this.pacman,\n            this.blinky,\n            this.pinky,\n            this.inky,\n            this.clyde,\n            this.fruit\n        ];\n        this.ghosts = [\n            this.blinky,\n            this.pinky,\n            this.inky,\n            this.clyde\n        ];\n        this.scaredGhosts = [];\n        this.eyeGhosts = 0;\n        if (this.firstGame) {\n            this.drawMaze(this.mazeArray, this.entityList);\n            this.soundManager = new $7fc2474486b8416c$var$SoundManager();\n            this.setUiDimensions();\n        } else {\n            this.pacman.reset();\n            this.ghosts.forEach((ghost)=>{\n                ghost.reset(true);\n            });\n            this.pickups.forEach((pickup)=>{\n                if (pickup.type !== \"fruit\") {\n                    this.remainingDots += 1;\n                    pickup.reset();\n                    this.entityList.push(pickup);\n                }\n            });\n        }\n        this.pointsDisplay.innerHTML = \"00\";\n        this.highScoreDisplay.innerHTML = this.highScore || \"00\";\n        this.clearDisplay(this.fruitDisplay);\n        const volumePreference = parseInt(localStorage.getItem(\"volumePreference\") || 1, 10);\n        this.setSoundButtonIcon(volumePreference);\n        this.soundManager.setMasterVolume(volumePreference);\n    }\n    /**\n   * Calls necessary setup functions to start the game\n   */ init() {\n        this.registerEventListeners();\n        this.gameEngine = new $7fc2474486b8416c$var$GameEngine(this.maxFps, this.entityList);\n        this.gameEngine.start();\n    }\n    /**\n   * Adds HTML elements to draw on the webpage by iterating through the 2D maze array\n   * @param {Array} mazeArray - 2D array representing the game board\n   * @param {Array} entityList - List of entities to be used throughout the game\n   */ drawMaze(mazeArray, entityList) {\n        this.pickups = [\n            this.fruit\n        ];\n        this.mazeDiv.style.height = `${this.scaledTileSize * 31}px`;\n        this.mazeDiv.style.width = `${this.scaledTileSize * 28}px`;\n        this.gameUi.style.width = `${this.scaledTileSize * 28}px`;\n        this.bottomRow.style.minHeight = `${this.scaledTileSize * 2}px`;\n        this.dotContainer = document.getElementById(\"dot-container\");\n        mazeArray.forEach((row, rowIndex)=>{\n            row.forEach((block, columnIndex)=>{\n                if (block === \"o\" || block === \"O\") {\n                    const type = block === \"o\" ? \"pacdot\" : \"powerPellet\";\n                    const points = block === \"o\" ? 10 : 50;\n                    const dot = new $7fc2474486b8416c$var$Pickup(type, this.scaledTileSize, columnIndex, rowIndex, this.pacman, this.dotContainer, points);\n                    entityList.push(dot);\n                    this.pickups.push(dot);\n                    this.remainingDots += 1;\n                }\n            });\n        });\n    }\n    setUiDimensions() {\n        this.gameUi.style.fontSize = `${this.scaledTileSize}px`;\n        this.rowTop.style.marginBottom = `${this.scaledTileSize}px`;\n    }\n    /**\n   * Loop which periodically checks which pickups are nearby Pacman.\n   * Pickups which are far away will not be considered for collision detection.\n   */ collisionDetectionLoop() {\n        if (this.pacman.position) {\n            const maxDistance = this.pacman.velocityPerMs * 750;\n            const pacmanCenter = {\n                x: this.pacman.position.left + this.scaledTileSize,\n                y: this.pacman.position.top + this.scaledTileSize\n            };\n            // Set this flag to TRUE to see how two-phase collision detection works!\n            const debugging = false;\n            this.pickups.forEach((pickup)=>{\n                pickup.checkPacmanProximity(maxDistance, pacmanCenter, debugging);\n            });\n        }\n    }\n    /**\n   * Displays \"Ready!\" and allows Pacman to move after a breif delay\n   * @param {Boolean} initialStart - Special condition for the game's beginning\n   */ startGameplay(initialStart) {\n        if (initialStart) this.soundManager.play(\"game_start\");\n        this.scaredGhosts = [];\n        this.eyeGhosts = 0;\n        this.allowPacmanMovement = false;\n        const left = this.scaledTileSize * 11;\n        const top = this.scaledTileSize * 16.5;\n        const duration = initialStart ? 4500 : 2000;\n        const width = this.scaledTileSize * 6;\n        const height = this.scaledTileSize * 2;\n        this.displayText({\n            left: left,\n            top: top\n        }, \"ready\", duration, width, height);\n        this.updateExtraLivesDisplay();\n        new $7fc2474486b8416c$var$Timer(()=>{\n            this.allowPause = true;\n            this.cutscene = false;\n            this.soundManager.setCutscene(this.cutscene);\n            this.soundManager.setAmbience(this.determineSiren(this.remainingDots));\n            this.allowPacmanMovement = true;\n            this.pacman.moving = true;\n            this.ghosts.forEach((ghost)=>{\n                const ghostRef = ghost;\n                ghostRef.moving = true;\n            });\n            this.ghostCycle(\"scatter\");\n            this.idleGhosts = [\n                this.pinky,\n                this.inky,\n                this.clyde\n            ];\n            this.releaseGhost();\n        }, duration);\n    }\n    /**\n   * Clears out all children nodes from a given display element\n   * @param {String} display\n   */ clearDisplay(display) {\n        while(display.firstChild)display.removeChild(display.firstChild);\n    }\n    /**\n   * Displays extra life images equal to the number of remaining lives\n   */ updateExtraLivesDisplay() {\n        this.clearDisplay(this.extraLivesDisplay);\n        for(let i = 0; i < this.lives; i += 1){\n            const extraLifePic = document.createElement(\"img\");\n            extraLifePic.setAttribute(\"src\", \"/style/graphics/extra_life.svg\");\n            extraLifePic.style.height = `${this.scaledTileSize * 2}px`;\n            this.extraLivesDisplay.appendChild(extraLifePic);\n        }\n    }\n    /**\n   * Displays a rolling log of the seven most-recently eaten fruit\n   * @param {String} rawImageSource\n   */ updateFruitDisplay(rawImageSource) {\n        const parsedSource = rawImageSource.slice(rawImageSource.indexOf(\"(\") + 1, rawImageSource.indexOf(\")\"));\n        if (this.fruitDisplay.children.length === 7) this.fruitDisplay.removeChild(this.fruitDisplay.firstChild);\n        const fruitPic = document.createElement(\"img\");\n        fruitPic.setAttribute(\"src\", parsedSource);\n        fruitPic.style.height = `${this.scaledTileSize * 2}px`;\n        this.fruitDisplay.appendChild(fruitPic);\n    }\n    /**\n   * Cycles the ghosts between 'chase' and 'scatter' mode\n   * @param {('chase'|'scatter')} mode\n   */ ghostCycle(mode) {\n        const delay = mode === \"scatter\" ? 7000 : 20000;\n        const nextMode = mode === \"scatter\" ? \"chase\" : \"scatter\";\n        this.ghostCycleTimer = new $7fc2474486b8416c$var$Timer(()=>{\n            this.ghosts.forEach((ghost)=>{\n                ghost.changeMode(nextMode);\n            });\n            this.ghostCycle(nextMode);\n        }, delay);\n    }\n    /**\n   * Releases a ghost from the Ghost House after a delay\n   */ releaseGhost() {\n        if (this.idleGhosts.length > 0) {\n            const delay = Math.max((8 - (this.level - 1) * 4) * 1000, 0);\n            this.endIdleTimer = new $7fc2474486b8416c$var$Timer(()=>{\n                this.idleGhosts[0].endIdleMode();\n                this.idleGhosts.shift();\n            }, delay);\n        }\n    }\n    /**\n   * Register listeners for various game sequences\n   */ registerEventListeners() {\n        window.addEventListener(\"keydown\", this.handleKeyDown.bind(this));\n        window.addEventListener(\"awardPoints\", this.awardPoints.bind(this));\n        window.addEventListener(\"deathSequence\", this.deathSequence.bind(this));\n        window.addEventListener(\"dotEaten\", this.dotEaten.bind(this));\n        window.addEventListener(\"powerUp\", this.powerUp.bind(this));\n        window.addEventListener(\"eatGhost\", this.eatGhost.bind(this));\n        window.addEventListener(\"restoreGhost\", this.restoreGhost.bind(this));\n        window.addEventListener(\"addTimer\", this.addTimer.bind(this));\n        window.addEventListener(\"removeTimer\", this.removeTimer.bind(this));\n        window.addEventListener(\"releaseGhost\", this.releaseGhost.bind(this));\n        const directions = [\n            \"up\",\n            \"down\",\n            \"left\",\n            \"right\"\n        ];\n        directions.forEach((direction)=>{\n            document.getElementById(`button-${direction}`).addEventListener(\"touchstart\", ()=>{\n                this.changeDirection(direction);\n            });\n        });\n    }\n    /**\n   * Calls Pacman's changeDirection event if certain conditions are met\n   * @param {({'up'|'down'|'left'|'right'})} direction\n   */ changeDirection(direction) {\n        if (this.allowKeyPresses && this.gameEngine.running) this.pacman.changeDirection(direction, this.allowPacmanMovement);\n    }\n    /**\n   * Calls various class functions depending upon the pressed key\n   * @param {Event} e - The keydown event to evaluate\n   */ handleKeyDown(e) {\n        if (e.keyCode === 27) // ESC key\n        this.handlePauseKey();\n        else if (e.keyCode === 81) // Q\n        this.soundButtonClick();\n        else if (this.movementKeys[e.keyCode]) this.changeDirection(this.movementKeys[e.keyCode]);\n    }\n    /**\n   * Handle behavior for the pause key\n   */ handlePauseKey() {\n        if (this.allowPause) {\n            this.allowPause = false;\n            setTimeout(()=>{\n                if (!this.cutscene) this.allowPause = true;\n            }, 500);\n            this.gameEngine.changePausedState(this.gameEngine.running);\n            this.soundManager.play(\"pause\");\n            if (this.gameEngine.started) {\n                this.soundManager.resumeAmbience();\n                this.gameUi.style.filter = \"unset\";\n                this.movementButtons.style.filter = \"unset\";\n                this.pausedText.style.visibility = \"hidden\";\n                this.pauseButton.innerHTML = \"pause\";\n                this.activeTimers.forEach((timer)=>{\n                    timer.resume();\n                });\n            } else {\n                this.soundManager.stopAmbience();\n                this.soundManager.setAmbience(\"pause_beat\", true);\n                this.gameUi.style.filter = \"blur(5px)\";\n                this.movementButtons.style.filter = \"blur(5px)\";\n                this.pausedText.style.visibility = \"visible\";\n                this.pauseButton.innerHTML = \"play_arrow\";\n                this.activeTimers.forEach((timer)=>{\n                    timer.pause();\n                });\n            }\n        }\n    }\n    /**\n   * Adds points to the player's total\n   * @param {({ detail: { points: Number }})} e - Contains a quantity of points to add\n   */ awardPoints(e) {\n        this.points += e.detail.points;\n        this.pointsDisplay.innerText = this.points;\n        if (this.points > (this.highScore || 0)) {\n            this.highScore = this.points;\n            this.highScoreDisplay.innerText = this.points;\n            localStorage.setItem(\"highScore\", this.highScore);\n        }\n        if (this.points >= 10000 && !this.extraLifeGiven) {\n            this.extraLifeGiven = true;\n            this.soundManager.play(\"extra_life\");\n            this.lives += 1;\n            this.updateExtraLivesDisplay();\n        }\n        if (e.detail.type === \"fruit\") {\n            const left = e.detail.points >= 1000 ? this.scaledTileSize * 12.5 : this.scaledTileSize * 13;\n            const top = this.scaledTileSize * 16.5;\n            const width = e.detail.points >= 1000 ? this.scaledTileSize * 3 : this.scaledTileSize * 2;\n            const height = this.scaledTileSize * 2;\n            this.displayText({\n                left: left,\n                top: top\n            }, e.detail.points, 2000, width, height);\n            this.soundManager.play(\"fruit\");\n            this.updateFruitDisplay(this.fruit.determineImage(\"fruit\", e.detail.points));\n        }\n    }\n    /**\n   * Animates Pacman's death, subtracts a life, and resets character positions if\n   * the player has remaining lives.\n   */ deathSequence() {\n        this.allowPause = false;\n        this.cutscene = true;\n        this.soundManager.setCutscene(this.cutscene);\n        this.soundManager.stopAmbience();\n        this.removeTimer({\n            detail: {\n                timer: this.fruitTimer\n            }\n        });\n        this.removeTimer({\n            detail: {\n                timer: this.ghostCycleTimer\n            }\n        });\n        this.removeTimer({\n            detail: {\n                timer: this.endIdleTimer\n            }\n        });\n        this.removeTimer({\n            detail: {\n                timer: this.ghostFlashTimer\n            }\n        });\n        this.allowKeyPresses = false;\n        this.pacman.moving = false;\n        this.ghosts.forEach((ghost)=>{\n            const ghostRef = ghost;\n            ghostRef.moving = false;\n        });\n        new $7fc2474486b8416c$var$Timer(()=>{\n            this.ghosts.forEach((ghost)=>{\n                const ghostRef = ghost;\n                ghostRef.display = false;\n            });\n            this.pacman.prepDeathAnimation();\n            this.soundManager.play(\"death\");\n            if (this.lives > 0) {\n                this.lives -= 1;\n                new $7fc2474486b8416c$var$Timer(()=>{\n                    this.mazeCover.style.visibility = \"visible\";\n                    new $7fc2474486b8416c$var$Timer(()=>{\n                        this.allowKeyPresses = true;\n                        this.mazeCover.style.visibility = \"hidden\";\n                        this.pacman.reset();\n                        this.ghosts.forEach((ghost)=>{\n                            ghost.reset();\n                        });\n                        this.fruit.hideFruit();\n                        this.startGameplay();\n                    }, 500);\n                }, 2250);\n            } else this.gameOver();\n        }, 750);\n    }\n    /**\n   * Displays GAME OVER text and displays the menu so players can play again\n   */ executeContract() {\n        console.log(\"Execute smart contract, check and set new hight score\", this.highScore) // TODO: this should be done\n        ;\n    }\n    gameOver() {\n        localStorage.setItem(\"highScore\", this.highScore);\n        // this.executeContract()\n        executeSmartContract(this.highScore);\n        new $7fc2474486b8416c$var$Timer(()=>{\n            this.displayText({\n                left: this.scaledTileSize * 9,\n                top: this.scaledTileSize * 16.5\n            }, \"game_over\", 4000, this.scaledTileSize * 10, this.scaledTileSize * 2);\n            this.fruit.hideFruit();\n            new $7fc2474486b8416c$var$Timer(()=>{\n                this.leftCover.style.left = \"0\";\n                this.rightCover.style.right = \"0\";\n                setTimeout(()=>{\n                    this.mainMenu.style.opacity = 1;\n                    this.gameStartButton.disabled = false;\n                    this.mainMenu.style.visibility = \"visible\";\n                }, 1000);\n            }, 2500);\n        }, 2250);\n    }\n    /**\n   * Handle events related to the number of remaining dots\n   */ dotEaten() {\n        this.remainingDots -= 1;\n        this.soundManager.playDotSound();\n        if (this.remainingDots === 174 || this.remainingDots === 74) this.createFruit();\n        if (this.remainingDots === 40 || this.remainingDots === 20) this.speedUpBlinky();\n        if (this.remainingDots === 0) this.advanceLevel();\n    }\n    /**\n   * Creates a bonus fruit for ten seconds\n   */ createFruit() {\n        this.removeTimer({\n            detail: {\n                timer: this.fruitTimer\n            }\n        });\n        this.fruit.showFruit(this.fruitPoints[this.level] || 5000);\n        this.fruitTimer = new $7fc2474486b8416c$var$Timer(()=>{\n            this.fruit.hideFruit();\n        }, 10000);\n    }\n    /**\n   * Speeds up Blinky and raises the background noise pitch\n   */ speedUpBlinky() {\n        this.blinky.speedUp();\n        if (this.scaredGhosts.length === 0 && this.eyeGhosts === 0) this.soundManager.setAmbience(this.determineSiren(this.remainingDots));\n    }\n    /**\n   * Determines the correct siren ambience\n   * @param {Number} remainingDots\n   * @returns {String}\n   */ determineSiren(remainingDots) {\n        let sirenNum;\n        if (remainingDots > 40) sirenNum = 1;\n        else if (remainingDots > 20) sirenNum = 2;\n        else sirenNum = 3;\n        return `siren_${sirenNum}`;\n    }\n    /**\n   * Resets the gameboard and prepares the next level\n   */ advanceLevel() {\n        this.allowPause = false;\n        this.cutscene = true;\n        this.soundManager.setCutscene(this.cutscene);\n        this.allowKeyPresses = false;\n        this.soundManager.stopAmbience();\n        this.entityList.forEach((entity)=>{\n            const entityRef = entity;\n            entityRef.moving = false;\n        });\n        this.removeTimer({\n            detail: {\n                timer: this.fruitTimer\n            }\n        });\n        this.removeTimer({\n            detail: {\n                timer: this.ghostCycleTimer\n            }\n        });\n        this.removeTimer({\n            detail: {\n                timer: this.endIdleTimer\n            }\n        });\n        this.removeTimer({\n            detail: {\n                timer: this.ghostFlashTimer\n            }\n        });\n        const imgBase = \"/style/graphics/spriteSheets/maze/\";\n        new $7fc2474486b8416c$var$Timer(()=>{\n            this.ghosts.forEach((ghost)=>{\n                const ghostRef = ghost;\n                ghostRef.display = false;\n            });\n            this.mazeImg.src = `${imgBase}maze_white.svg`;\n            new $7fc2474486b8416c$var$Timer(()=>{\n                this.mazeImg.src = `${imgBase}maze_blue.svg`;\n                new $7fc2474486b8416c$var$Timer(()=>{\n                    this.mazeImg.src = `${imgBase}maze_white.svg`;\n                    new $7fc2474486b8416c$var$Timer(()=>{\n                        this.mazeImg.src = `${imgBase}maze_blue.svg`;\n                        new $7fc2474486b8416c$var$Timer(()=>{\n                            this.mazeImg.src = `${imgBase}maze_white.svg`;\n                            new $7fc2474486b8416c$var$Timer(()=>{\n                                this.mazeImg.src = `${imgBase}maze_blue.svg`;\n                                new $7fc2474486b8416c$var$Timer(()=>{\n                                    this.mazeCover.style.visibility = \"visible\";\n                                    new $7fc2474486b8416c$var$Timer(()=>{\n                                        this.mazeCover.style.visibility = \"hidden\";\n                                        this.level += 1;\n                                        this.allowKeyPresses = true;\n                                        this.entityList.forEach((entity)=>{\n                                            const entityRef = entity;\n                                            if (entityRef.level) entityRef.level = this.level;\n                                            entityRef.reset();\n                                            if (entityRef instanceof $7fc2474486b8416c$var$Ghost) entityRef.resetDefaultSpeed();\n                                            if (entityRef instanceof $7fc2474486b8416c$var$Pickup && entityRef.type !== \"fruit\") this.remainingDots += 1;\n                                        });\n                                        this.startGameplay();\n                                    }, 500);\n                                }, 250);\n                            }, 250);\n                        }, 250);\n                    }, 250);\n                }, 250);\n            }, 250);\n        }, 2000);\n    }\n    /**\n   * Flashes ghosts blue and white to indicate the end of the powerup\n   * @param {Number} flashes - Total number of elapsed flashes\n   * @param {Number} maxFlashes - Total flashes to show\n   */ flashGhosts(flashes, maxFlashes) {\n        if (flashes === maxFlashes) {\n            this.scaredGhosts.forEach((ghost)=>{\n                ghost.endScared();\n            });\n            this.scaredGhosts = [];\n            if (this.eyeGhosts === 0) this.soundManager.setAmbience(this.determineSiren(this.remainingDots));\n        } else if (this.scaredGhosts.length > 0) {\n            this.scaredGhosts.forEach((ghost)=>{\n                ghost.toggleScaredColor();\n            });\n            this.ghostFlashTimer = new $7fc2474486b8416c$var$Timer(()=>{\n                this.flashGhosts(flashes + 1, maxFlashes);\n            }, 250);\n        }\n    }\n    /**\n   * Upon eating a power pellet, sets the ghosts to 'scared' mode\n   */ powerUp() {\n        if (this.remainingDots !== 0) this.soundManager.setAmbience(\"power_up\");\n        this.removeTimer({\n            detail: {\n                timer: this.ghostFlashTimer\n            }\n        });\n        this.ghostCombo = 0;\n        this.scaredGhosts = [];\n        this.ghosts.forEach((ghost)=>{\n            if (ghost.mode !== \"eyes\") this.scaredGhosts.push(ghost);\n        });\n        this.scaredGhosts.forEach((ghost)=>{\n            ghost.becomeScared();\n        });\n        const powerDuration = Math.max((7 - this.level) * 1000, 0);\n        this.ghostFlashTimer = new $7fc2474486b8416c$var$Timer(()=>{\n            this.flashGhosts(0, 9);\n        }, powerDuration);\n    }\n    /**\n   * Determines the quantity of points to give based on the current combo\n   */ determineComboPoints() {\n        return 100 * 2 ** this.ghostCombo;\n    }\n    /**\n   * Upon eating a ghost, award points and temporarily pause movement\n   * @param {CustomEvent} e - Contains a target ghost object\n   */ eatGhost(e) {\n        const pauseDuration = 1000;\n        const { position: position , measurement: measurement  } = e.detail.ghost;\n        this.pauseTimer({\n            detail: {\n                timer: this.ghostFlashTimer\n            }\n        });\n        this.pauseTimer({\n            detail: {\n                timer: this.ghostCycleTimer\n            }\n        });\n        this.pauseTimer({\n            detail: {\n                timer: this.fruitTimer\n            }\n        });\n        this.soundManager.play(\"eat_ghost\");\n        this.scaredGhosts = this.scaredGhosts.filter((ghost)=>ghost.name !== e.detail.ghost.name);\n        this.eyeGhosts += 1;\n        this.ghostCombo += 1;\n        const comboPoints = this.determineComboPoints();\n        window.dispatchEvent(new CustomEvent(\"awardPoints\", {\n            detail: {\n                points: comboPoints\n            }\n        }));\n        this.displayText(position, comboPoints, pauseDuration, measurement);\n        this.allowPacmanMovement = false;\n        this.pacman.display = false;\n        this.pacman.moving = false;\n        e.detail.ghost.display = false;\n        e.detail.ghost.moving = false;\n        this.ghosts.forEach((ghost)=>{\n            const ghostRef = ghost;\n            ghostRef.animate = false;\n            ghostRef.pause(true);\n            ghostRef.allowCollision = false;\n        });\n        new $7fc2474486b8416c$var$Timer(()=>{\n            this.soundManager.setAmbience(\"eyes\");\n            this.resumeTimer({\n                detail: {\n                    timer: this.ghostFlashTimer\n                }\n            });\n            this.resumeTimer({\n                detail: {\n                    timer: this.ghostCycleTimer\n                }\n            });\n            this.resumeTimer({\n                detail: {\n                    timer: this.fruitTimer\n                }\n            });\n            this.allowPacmanMovement = true;\n            this.pacman.display = true;\n            this.pacman.moving = true;\n            e.detail.ghost.display = true;\n            e.detail.ghost.moving = true;\n            this.ghosts.forEach((ghost)=>{\n                const ghostRef = ghost;\n                ghostRef.animate = true;\n                ghostRef.pause(false);\n                ghostRef.allowCollision = true;\n            });\n        }, pauseDuration);\n    }\n    /**\n   * Decrements the count of \"eye\" ghosts and updates the ambience\n   */ restoreGhost() {\n        this.eyeGhosts -= 1;\n        if (this.eyeGhosts === 0) {\n            const sound = this.scaredGhosts.length > 0 ? \"power_up\" : this.determineSiren(this.remainingDots);\n            this.soundManager.setAmbience(sound);\n        }\n    }\n    /**\n   * Creates a temporary div to display points on screen\n   * @param {({ left: number, top: number })} position - CSS coordinates to display the points at\n   * @param {Number} amount - Amount of points to display\n   * @param {Number} duration - Milliseconds to display the points before disappearing\n   * @param {Number} width - Image width in pixels\n   * @param {Number} height - Image height in pixels\n   */ displayText(position, amount, duration, width, height) {\n        const pointsDiv = document.createElement(\"div\");\n        pointsDiv.style.position = \"absolute\";\n        pointsDiv.style.backgroundSize = `${width}px`;\n        pointsDiv.style.backgroundImage = \"url(/style/graphics/\" + `spriteSheets/text/${amount}.svg`;\n        pointsDiv.style.width = `${width}px`;\n        pointsDiv.style.height = `${height || width}px`;\n        pointsDiv.style.top = `${position.top}px`;\n        pointsDiv.style.left = `${position.left}px`;\n        pointsDiv.style.zIndex = 2;\n        this.mazeDiv.appendChild(pointsDiv);\n        new $7fc2474486b8416c$var$Timer(()=>{\n            this.mazeDiv.removeChild(pointsDiv);\n        }, duration);\n    }\n    /**\n   * Pushes a Timer to the activeTimers array\n   * @param {({ detail: { timer: Object }})} e\n   */ addTimer(e) {\n        this.activeTimers.push(e.detail.timer);\n    }\n    /**\n   * Checks if a Timer with a matching ID exists\n   * @param {({ detail: { timer: Object }})} e\n   * @returns {Boolean}\n   */ timerExists(e) {\n        return !!(e.detail.timer || {}).timerId;\n    }\n    /**\n   * Pauses a timer\n   * @param {({ detail: { timer: Object }})} e\n   */ pauseTimer(e) {\n        if (this.timerExists(e)) e.detail.timer.pause(true);\n    }\n    /**\n   * Resumes a timer\n   * @param {({ detail: { timer: Object }})} e\n   */ resumeTimer(e) {\n        if (this.timerExists(e)) e.detail.timer.resume(true);\n    }\n    /**\n   * Removes a Timer from activeTimers\n   * @param {({ detail: { timer: Object }})} e\n   */ removeTimer(e) {\n        if (this.timerExists(e)) {\n            window.clearTimeout(e.detail.timer.timerId);\n            this.activeTimers = this.activeTimers.filter((timer)=>timer.timerId !== e.detail.timer.timerId);\n        }\n    }\n}\nclass $7fc2474486b8416c$var$GameEngine {\n    constructor(maxFps, entityList){\n        this.fpsDisplay = document.getElementById(\"fps-display\");\n        this.elapsedMs = 0;\n        this.lastFrameTimeMs = 0;\n        this.entityList = entityList;\n        this.maxFps = maxFps;\n        this.timestep = 1000 / this.maxFps;\n        this.fps = this.maxFps;\n        this.framesThisSecond = 0;\n        this.lastFpsUpdate = 0;\n        this.frameId = 0;\n        this.running = false;\n        this.started = false;\n    }\n    /**\n   * Toggles the paused/running status of the game\n   * @param {Boolean} running - Whether the game is currently in motion\n   */ changePausedState(running) {\n        if (running) this.stop();\n        else this.start();\n    }\n    /**\n   * Updates the on-screen FPS counter once per second\n   * @param {number} timestamp - The amount of MS which has passed since starting the game engine\n   */ updateFpsDisplay(timestamp) {\n        if (timestamp > this.lastFpsUpdate + 1000) {\n            this.fps = (this.framesThisSecond + this.fps) / 2;\n            this.lastFpsUpdate = timestamp;\n            this.framesThisSecond = 0;\n        }\n        this.framesThisSecond += 1;\n        this.fpsDisplay.textContent = `${Math.round(this.fps)} FPS`;\n    }\n    /**\n   * Calls the draw function for every member of the entityList\n   * @param {number} interp - The animation accuracy as a percentage\n   * @param {Array} entityList - List of entities to be used throughout the game\n   */ draw(interp, entityList) {\n        entityList.forEach((entity)=>{\n            if (typeof entity.draw === \"function\") entity.draw(interp);\n        });\n    }\n    /**\n   * Calls the update function for every member of the entityList\n   * @param {number} elapsedMs - The amount of MS that have passed since the last update\n   * @param {Array} entityList - List of entities to be used throughout the game\n   */ update(elapsedMs, entityList) {\n        entityList.forEach((entity)=>{\n            if (typeof entity.update === \"function\") entity.update(elapsedMs);\n        });\n    }\n    /**\n   * In the event that a ton of unsimulated frames pile up, discard all of these frames\n   * to prevent crashing the game\n   */ panic() {\n        this.elapsedMs = 0;\n    }\n    /**\n   * Draws an initial frame, resets a few tracking variables related to animation, and calls\n   * the mainLoop function to start the engine\n   */ start() {\n        if (!this.started) {\n            this.started = true;\n            this.frameId = requestAnimationFrame((firstTimestamp)=>{\n                this.draw(1, []);\n                this.running = true;\n                this.lastFrameTimeMs = firstTimestamp;\n                this.lastFpsUpdate = firstTimestamp;\n                this.framesThisSecond = 0;\n                this.frameId = requestAnimationFrame((timestamp)=>{\n                    this.mainLoop(timestamp);\n                });\n            });\n        }\n    }\n    /**\n   * Stops the engine and cancels the current animation frame\n   */ stop() {\n        this.running = false;\n        this.started = false;\n        cancelAnimationFrame(this.frameId);\n    }\n    /**\n   * The loop which will process all necessary frames to update the game's entities\n   * prior to animating them\n   */ processFrames() {\n        let numUpdateSteps = 0;\n        while(this.elapsedMs >= this.timestep){\n            this.update(this.timestep, this.entityList);\n            this.elapsedMs -= this.timestep;\n            numUpdateSteps += 1;\n            if (numUpdateSteps >= this.maxFps) {\n                this.panic();\n                break;\n            }\n        }\n    }\n    /**\n   * A single cycle of the engine which checks to see if enough time has passed, and, if so,\n   * will kick off the loops to update and draw the game's entities.\n   * @param {number} timestamp - The amount of MS which has passed since starting the game engine\n   */ engineCycle(timestamp) {\n        if (timestamp < this.lastFrameTimeMs + 1000 / this.maxFps) {\n            this.frameId = requestAnimationFrame((nextTimestamp)=>{\n                this.mainLoop(nextTimestamp);\n            });\n            return;\n        }\n        this.elapsedMs += timestamp - this.lastFrameTimeMs;\n        this.lastFrameTimeMs = timestamp;\n        this.updateFpsDisplay(timestamp);\n        this.processFrames();\n        this.draw(this.elapsedMs / this.timestep, this.entityList);\n        this.frameId = requestAnimationFrame((nextTimestamp)=>{\n            this.mainLoop(nextTimestamp);\n        });\n    }\n    /**\n   * The endless loop which will kick off engine cycles so long as the game is running\n   * @param {number} timestamp - The amount of MS which has passed since starting the game engine\n   */ mainLoop(timestamp) {\n        this.engineCycle(timestamp);\n    }\n}\nclass $7fc2474486b8416c$var$Pickup {\n    constructor(type, scaledTileSize, column, row, pacman, mazeDiv, points){\n        this.type = type;\n        this.pacman = pacman;\n        this.mazeDiv = mazeDiv;\n        this.points = points;\n        this.nearPacman = false;\n        this.fruitImages = {\n            100: \"cherry\",\n            300: \"strawberry\",\n            500: \"orange\",\n            700: \"apple\",\n            1000: \"melon\",\n            2000: \"galaxian\",\n            3000: \"bell\",\n            5000: \"key\"\n        };\n        this.setStyleMeasurements(type, scaledTileSize, column, row, points);\n    }\n    /**\n   * Resets the pickup's visibility\n   */ reset() {\n        this.animationTarget.style.visibility = this.type === \"fruit\" ? \"hidden\" : \"visible\";\n    }\n    /**\n   * Sets various style measurements for the pickup depending on its type\n   * @param {('pacdot'|'powerPellet'|'fruit')} type - The classification of pickup\n   * @param {number} scaledTileSize\n   * @param {number} column\n   * @param {number} row\n   * @param {number} points\n   */ setStyleMeasurements(type, scaledTileSize, column, row, points) {\n        if (type === \"pacdot\") {\n            this.size = scaledTileSize * 0.25;\n            this.x = column * scaledTileSize + scaledTileSize / 8 * 3;\n            this.y = row * scaledTileSize + scaledTileSize / 8 * 3;\n        } else if (type === \"powerPellet\") {\n            this.size = scaledTileSize;\n            this.x = column * scaledTileSize;\n            this.y = row * scaledTileSize;\n        } else {\n            this.size = scaledTileSize * 2;\n            this.x = column * scaledTileSize - scaledTileSize * 0.5;\n            this.y = row * scaledTileSize - scaledTileSize * 0.5;\n        }\n        this.center = {\n            x: column * scaledTileSize,\n            y: row * scaledTileSize\n        };\n        this.animationTarget = document.createElement(\"div\");\n        this.animationTarget.style.position = \"absolute\";\n        this.animationTarget.style.backgroundSize = `${this.size}px`;\n        this.animationTarget.style.backgroundImage = this.determineImage(type, points);\n        this.animationTarget.style.height = `${this.size}px`;\n        this.animationTarget.style.width = `${this.size}px`;\n        this.animationTarget.style.top = `${this.y}px`;\n        this.animationTarget.style.left = `${this.x}px`;\n        this.mazeDiv.appendChild(this.animationTarget);\n        if (type === \"powerPellet\") this.animationTarget.classList.add(\"power-pellet\");\n        this.reset();\n    }\n    /**\n   * Determines the Pickup image based on type and point value\n   * @param {('pacdot'|'powerPellet'|'fruit')} type - The classification of pickup\n   * @param {Number} points\n   * @returns {String}\n   */ determineImage(type, points) {\n        let image = \"\";\n        if (type === \"fruit\") image = this.fruitImages[points] || \"cherry\";\n        else image = type;\n        return `url(/style/graphics/spriteSheets/pickups/${image}.svg)`;\n    }\n    /**\n   * Shows a bonus fruit, resetting its point value and image\n   * @param {number} points\n   */ showFruit(points) {\n        this.points = points;\n        this.animationTarget.style.backgroundImage = this.determineImage(this.type, points);\n        this.animationTarget.style.visibility = \"visible\";\n    }\n    /**\n   * Makes the fruit invisible (happens if Pacman was too slow)\n   */ hideFruit() {\n        this.animationTarget.style.visibility = \"hidden\";\n    }\n    /**\n   * Returns true if the Pickup is touching a bounding box at Pacman's center\n   * @param {({ x: number, y: number, size: number})} pickup\n   * @param {({ x: number, y: number, size: number})} originalPacman\n   */ checkForCollision(pickup, originalPacman) {\n        const pacman = Object.assign({}, originalPacman);\n        pacman.x += pacman.size * 0.25;\n        pacman.y += pacman.size * 0.25;\n        pacman.size /= 2;\n        return pickup.x < pacman.x + pacman.size && pickup.x + pickup.size > pacman.x && pickup.y < pacman.y + pacman.size && pickup.y + pickup.size > pacman.y;\n    }\n    /**\n   * Checks to see if the pickup is close enough to Pacman to be considered for collision detection\n   * @param {number} maxDistance - The maximum distance Pacman can travel per cycle\n   * @param {({ x:number, y:number })} pacmanCenter - The center of Pacman's hitbox\n   * @param {Boolean} debugging - Flag to change the appearance of pickups for testing\n   */ checkPacmanProximity(maxDistance, pacmanCenter, debugging) {\n        if (this.animationTarget.style.visibility !== \"hidden\") {\n            const distance = Math.sqrt((this.center.x - pacmanCenter.x) ** 2 + (this.center.y - pacmanCenter.y) ** 2);\n            this.nearPacman = distance <= maxDistance;\n            if (debugging) this.animationTarget.style.background = this.nearPacman ? \"lime\" : \"red\";\n        }\n    }\n    /**\n   * Checks if the pickup is visible and close to Pacman\n   * @returns {Boolean}\n   */ shouldCheckForCollision() {\n        return this.animationTarget.style.visibility !== \"hidden\" && this.nearPacman;\n    }\n    /**\n   * If the Pickup is still visible, it checks to see if it is colliding with Pacman.\n   * It will turn itself invisible and cease collision-detection after the first\n   * collision with Pacman.\n   */ update() {\n        if (this.shouldCheckForCollision()) {\n            if (this.checkForCollision({\n                x: this.x,\n                y: this.y,\n                size: this.size\n            }, {\n                x: this.pacman.position.left,\n                y: this.pacman.position.top,\n                size: this.pacman.measurement\n            })) {\n                this.animationTarget.style.visibility = \"hidden\";\n                window.dispatchEvent(new CustomEvent(\"awardPoints\", {\n                    detail: {\n                        points: this.points,\n                        type: this.type\n                    }\n                }));\n                if (this.type === \"pacdot\") window.dispatchEvent(new Event(\"dotEaten\"));\n                else if (this.type === \"powerPellet\") {\n                    window.dispatchEvent(new Event(\"dotEaten\"));\n                    window.dispatchEvent(new Event(\"powerUp\"));\n                }\n            }\n        }\n    }\n}\nclass $7fc2474486b8416c$var$CharacterUtil {\n    constructor(){\n        this.directions = {\n            up: \"up\",\n            down: \"down\",\n            left: \"left\",\n            right: \"right\"\n        };\n    }\n    /**\n   * Check if a given character has moved more than five in-game tiles during a frame.\n   * If so, we want to temporarily hide the object to avoid 'animation stutter'.\n   * @param {({top: number, left: number})} position - Position during the current frame\n   * @param {({top: number, left: number})} oldPosition - Position during the previous frame\n   * @returns {('hidden'|'visible')} - The new 'visibility' css property value for the character.\n   */ checkForStutter(position, oldPosition) {\n        let stutter = false;\n        const threshold = 5;\n        if (position && oldPosition) {\n            if (Math.abs(position.top - oldPosition.top) > threshold || Math.abs(position.left - oldPosition.left) > threshold) stutter = true;\n        }\n        return stutter ? \"hidden\" : \"visible\";\n    }\n    /**\n   * Check which CSS property needs to be changed given the character's current direction\n   * @param {('up'|'down'|'left'|'right')} direction - The character's current travel orientation\n   * @returns {('top'|'left')}\n   */ getPropertyToChange(direction) {\n        switch(direction){\n            case this.directions.up:\n            case this.directions.down:\n                return \"top\";\n            default:\n                return \"left\";\n        }\n    }\n    /**\n   * Calculate the velocity for the character's next frame.\n   * @param {('up'|'down'|'left'|'right')} direction - The character's current travel orientation\n   * @param {number} velocityPerMs - The distance to travel in a single millisecond\n   * @returns {number} - Moving down or right is positive, while up or left is negative.\n   */ getVelocity(direction, velocityPerMs) {\n        switch(direction){\n            case this.directions.up:\n            case this.directions.left:\n                return velocityPerMs * -1;\n            default:\n                return velocityPerMs;\n        }\n    }\n    /**\n   * Determine the next value which will be used to draw the character's position on screen\n   * @param {number} interp - The percentage of the desired timestamp between frames\n   * @param {('top'|'left')} prop - The css property to be changed\n   * @param {({top: number, left: number})} oldPosition - Position during the previous frame\n   * @param {({top: number, left: number})} position - Position during the current frame\n   * @returns {number} - New value for css positioning\n   */ calculateNewDrawValue(interp, prop, oldPosition, position) {\n        return oldPosition[prop] + (position[prop] - oldPosition[prop]) * interp;\n    }\n    /**\n   * Convert the character's css position to a row-column on the maze array\n   * @param {('up'|'down'|'left'|'right')} direction - The character's current travel orientation\n   * @param {number} scaledTileSize - The dimensions of a single tile\n   * @returns {({x: number, y: number})}\n   */ determineGridPosition(position, scaledTileSize) {\n        return {\n            x: position.left / scaledTileSize + 0.5,\n            y: position.top / scaledTileSize + 0.5\n        };\n    }\n    /**\n   * Check to see if a character's disired direction results in turning around\n   * @param {('up'|'down'|'left'|'right')} direction - The character's current travel orientation\n   * @param {('up'|'down'|'left'|'right')} desiredDirection - Character's desired orientation\n   * @returns {boolean}\n   */ turningAround(direction, desiredDirection) {\n        return desiredDirection === this.getOppositeDirection(direction);\n    }\n    /**\n   * Calculate the opposite of a given direction\n   * @param {('up'|'down'|'left'|'right')} direction - The character's current travel orientation\n   * @returns {('up'|'down'|'left'|'right')}\n   */ getOppositeDirection(direction) {\n        switch(direction){\n            case this.directions.up:\n                return this.directions.down;\n            case this.directions.down:\n                return this.directions.up;\n            case this.directions.left:\n                return this.directions.right;\n            default:\n                return this.directions.left;\n        }\n    }\n    /**\n   * Calculate the proper rounding function to assist with collision detection\n   * @param {('up'|'down'|'left'|'right')} direction - The character's current travel orientation\n   * @returns {Function}\n   */ determineRoundingFunction(direction) {\n        switch(direction){\n            case this.directions.up:\n            case this.directions.left:\n                return Math.floor;\n            default:\n                return Math.ceil;\n        }\n    }\n    /**\n   * Check to see if the character's next frame results in moving to a new tile on the maze array\n   * @param {({x: number, y: number})} oldPosition - Position during the previous frame\n   * @param {({x: number, y: number})} position - Position during the current frame\n   * @returns {boolean}\n   */ changingGridPosition(oldPosition, position) {\n        return Math.floor(oldPosition.x) !== Math.floor(position.x) || Math.floor(oldPosition.y) !== Math.floor(position.y);\n    }\n    /**\n   * Check to see if the character is attempting to run into a wall of the maze\n   * @param {({x: number, y: number})} desiredNewGridPosition - Character's target tile\n   * @param {Array} mazeArray - The 2D array representing the game's maze\n   * @param {('up'|'down'|'left'|'right')} direction - The character's current travel orientation\n   * @returns {boolean}\n   */ checkForWallCollision(desiredNewGridPosition, mazeArray, direction) {\n        const roundingFunction = this.determineRoundingFunction(direction, this.directions);\n        const desiredX = roundingFunction(desiredNewGridPosition.x);\n        const desiredY = roundingFunction(desiredNewGridPosition.y);\n        let newGridValue;\n        if (Array.isArray(mazeArray[desiredY])) newGridValue = mazeArray[desiredY][desiredX];\n        return newGridValue === \"X\";\n    }\n    /**\n   * Returns an object containing the new position and grid position based upon a direction\n   * @param {({top: number, left: number})} position - css position during the current frame\n   * @param {('up'|'down'|'left'|'right')} direction - The character's current travel orientation\n   * @param {number} velocityPerMs - The distance to travel in a single millisecond\n   * @param {number} elapsedMs - The amount of MS that have passed since the last update\n   * @param {number} scaledTileSize - The dimensions of a single tile\n   * @returns {object}\n   */ determineNewPositions(position, direction, velocityPerMs, elapsedMs, scaledTileSize) {\n        const newPosition = Object.assign({}, position);\n        newPosition[this.getPropertyToChange(direction)] += this.getVelocity(direction, velocityPerMs) * elapsedMs;\n        const newGridPosition = this.determineGridPosition(newPosition, scaledTileSize);\n        return {\n            newPosition: newPosition,\n            newGridPosition: newGridPosition\n        };\n    }\n    /**\n   * Calculates the css position when snapping the character to the x-y grid\n   * @param {({x: number, y: number})} position - The character's position during the current frame\n   * @param {('up'|'down'|'left'|'right')} direction - The character's current travel orientation\n   * @param {number} scaledTileSize - The dimensions of a single tile\n   * @returns {({top: number, left: number})}\n   */ snapToGrid(position, direction, scaledTileSize) {\n        const newPosition = Object.assign({}, position);\n        const roundingFunction = this.determineRoundingFunction(direction, this.directions);\n        switch(direction){\n            case this.directions.up:\n            case this.directions.down:\n                newPosition.y = roundingFunction(newPosition.y);\n                break;\n            default:\n                newPosition.x = roundingFunction(newPosition.x);\n                break;\n        }\n        return {\n            top: (newPosition.y - 0.5) * scaledTileSize,\n            left: (newPosition.x - 0.5) * scaledTileSize\n        };\n    }\n    /**\n   * Returns a modified position if the character needs to warp\n   * @param {({top: number, left: number})} position - css position during the current frame\n   * @param {({x: number, y: number})} gridPosition - x-y position during the current frame\n   * @param {number} scaledTileSize - The dimensions of a single tile\n   * @returns {({top: number, left: number})}\n   */ handleWarp(position, scaledTileSize, mazeArray) {\n        const newPosition = Object.assign({}, position);\n        const gridPosition = this.determineGridPosition(position, scaledTileSize);\n        if (gridPosition.x < -0.75) newPosition.left = scaledTileSize * (mazeArray[0].length - 0.75);\n        else if (gridPosition.x > mazeArray[0].length - 0.25) newPosition.left = scaledTileSize * -1.25;\n        return newPosition;\n    }\n    /**\n   * Advances spritesheet by one frame if needed\n   * @param {Object} character - The character which needs to be animated\n   */ advanceSpriteSheet(character) {\n        const { msSinceLastSprite: msSinceLastSprite , animationTarget: animationTarget , backgroundOffsetPixels: backgroundOffsetPixels  } = character;\n        const updatedProperties = {\n            msSinceLastSprite: msSinceLastSprite,\n            animationTarget: animationTarget,\n            backgroundOffsetPixels: backgroundOffsetPixels\n        };\n        const ready = character.msSinceLastSprite > character.msBetweenSprites && character.animate;\n        if (ready) {\n            updatedProperties.msSinceLastSprite = 0;\n            if (character.backgroundOffsetPixels < character.measurement * (character.spriteFrames - 1)) updatedProperties.backgroundOffsetPixels += character.measurement;\n            else if (character.loopAnimation) updatedProperties.backgroundOffsetPixels = 0;\n            const style = `-${updatedProperties.backgroundOffsetPixels}px 0px`;\n            updatedProperties.animationTarget.style.backgroundPosition = style;\n        }\n        return updatedProperties;\n    }\n}\nclass $7fc2474486b8416c$var$SoundManager {\n    constructor(){\n        this.baseUrl = \"/style/audio/\";\n        this.fileFormat = \"mp3\";\n        this.masterVolume = 1;\n        this.paused = false;\n        this.cutscene = true;\n        const AudioContext = window.AudioContext || window.webkitAudioContext;\n        this.ambience = new AudioContext();\n    }\n    /**\n   * Sets the cutscene flag to determine if players should be able to resume ambience\n   * @param {Boolean} newValue\n   */ setCutscene(newValue) {\n        this.cutscene = newValue;\n    }\n    /**\n   * Sets the master volume for all sounds and stops/resumes ambience\n   * @param {(0|1)} newVolume\n   */ setMasterVolume(newVolume) {\n        this.masterVolume = newVolume;\n        if (this.soundEffect) this.soundEffect.volume = this.masterVolume;\n        if (this.dotPlayer) this.dotPlayer.volume = this.masterVolume;\n        if (this.masterVolume === 0) this.stopAmbience();\n        else this.resumeAmbience(this.paused);\n    }\n    /**\n   * Plays a single sound effect\n   * @param {String} sound\n   */ play(sound) {\n        this.soundEffect = new Audio(`${this.baseUrl}${sound}.${this.fileFormat}`);\n        this.soundEffect.volume = this.masterVolume;\n        this.soundEffect.play();\n    }\n    /**\n   * Special method for eating dots. The dots should alternate between two\n   * sound effects, but not too quickly.\n   */ playDotSound() {\n        this.queuedDotSound = true;\n        if (!this.dotPlayer) {\n            this.queuedDotSound = false;\n            this.dotSound = this.dotSound === 1 ? 2 : 1;\n            this.dotPlayer = new Audio(`${this.baseUrl}dot_${this.dotSound}.${this.fileFormat}`);\n            this.dotPlayer.onended = this.dotSoundEnded.bind(this);\n            this.dotPlayer.volume = this.masterVolume;\n            this.dotPlayer.play();\n        }\n    }\n    /**\n   * Deletes the dotSound player and plays another dot sound if needed\n   */ dotSoundEnded() {\n        this.dotPlayer = undefined;\n        if (this.queuedDotSound) this.playDotSound();\n    }\n    /**\n   * Loops an ambient sound\n   * @param {String} sound\n   */ async setAmbience(sound, keepCurrentAmbience) {\n        if (!this.fetchingAmbience && !this.cutscene) {\n            if (!keepCurrentAmbience) {\n                this.currentAmbience = sound;\n                this.paused = false;\n            } else this.paused = true;\n            if (this.ambienceSource) this.ambienceSource.stop();\n            if (this.masterVolume !== 0) {\n                this.fetchingAmbience = true;\n                const response = await fetch(`${this.baseUrl}${sound}.${this.fileFormat}`);\n                const arrayBuffer = await response.arrayBuffer();\n                const audioBuffer = await this.ambience.decodeAudioData(arrayBuffer);\n                this.ambienceSource = this.ambience.createBufferSource();\n                this.ambienceSource.buffer = audioBuffer;\n                this.ambienceSource.connect(this.ambience.destination);\n                this.ambienceSource.loop = true;\n                this.ambienceSource.start();\n                this.fetchingAmbience = false;\n            }\n        }\n    }\n    /**\n   * Resumes the ambience\n   */ resumeAmbience(paused) {\n        if (this.ambienceSource) {\n            // Resetting the ambience since an AudioBufferSourceNode can only\n            // have 'start()' called once\n            if (paused) this.setAmbience(\"pause_beat\", true);\n            else this.setAmbience(this.currentAmbience);\n        }\n    }\n    /**\n   * Stops the ambience\n   */ stopAmbience() {\n        if (this.ambienceSource) this.ambienceSource.stop();\n    }\n}\nclass $7fc2474486b8416c$var$Timer {\n    constructor(callback, delay){\n        this.callback = callback;\n        this.remaining = delay;\n        this.resume();\n    }\n    /**\n   * Pauses the timer marks whether the pause came from the player\n   * or the system\n   * @param {Boolean} systemPause\n   */ pause(systemPause) {\n        window.clearTimeout(this.timerId);\n        this.remaining -= new Date() - this.start;\n        this.oldTimerId = this.timerId;\n        if (systemPause) this.pausedBySystem = true;\n    }\n    /**\n   * Creates a new setTimeout based upon the remaining time, giving the\n   * illusion of 'resuming' the old setTimeout\n   * @param {Boolean} systemResume\n   */ resume(systemResume) {\n        if (systemResume || !this.pausedBySystem) {\n            this.pausedBySystem = false;\n            this.start = new Date();\n            this.timerId = window.setTimeout(()=>{\n                this.callback();\n                window.dispatchEvent(new CustomEvent(\"removeTimer\", {\n                    detail: {\n                        timer: this\n                    }\n                }));\n            }, this.remaining);\n            if (!this.oldTimerId) window.dispatchEvent(new CustomEvent(\"addTimer\", {\n                detail: {\n                    timer: this\n                }\n            }));\n        }\n    }\n}\n\n\n\nfunction $3260655c7f105486$export$2b296bc7b2c2a18d() {\n    console.log(\"init coordinator\");\n    let gameCoordinator = new (0, $7fc2474486b8416c$export$fb4646ab13eb7425)();\n    console.log(\"gameCoordinator is laoded\", gameCoordinator);\n}\nasync function $3260655c7f105486$var$loadScoreboard() {\n    const responseList = document.getElementById(\"scoreboard\");\n    // const response = await fetch(\"https://api.github.com/users/hadley/orgs\");\n    // const jsonData = await response.json();\n    // console.log(jsonData);\n    // for (let i = 0; i < jsonData.length; i++) {\n    //   console.log(\"iterating...\", i)\n    //   const name = jsonData[i].login;\n    //   const scoreElements = document.createElement(\"div\");\n    //   scoreElements.innerHTML = `<a>${name}</a>`;\n    //   responseList.appendChild(scoreElements);\n    // }\n    for(let i = 0; i < 100; i++){\n        const userName = \"Wotori\";\n        const scoreElements = document.createElement(\"div\");\n        scoreElements.innerHTML = `<p style=\"margin: 3px\">${i + 1} - ${userName} - score</p>`;\n        responseList.appendChild(scoreElements);\n    }\n}\nwindow.onload = ()=>{\n    $3260655c7f105486$export$2b296bc7b2c2a18d();\n    $3260655c7f105486$var$loadScoreboard();\n};\n\n\n//# sourceMappingURL=index.016fbd5b.js.map\n","import { GameCoordinator } from \"./app\";\nimport styles from \"./app.css\";\n\nexport function initCoordinator() {\n  console.log(\"init coordinator\");\n  let gameCoordinator = new GameCoordinator();\n  console.log(\"gameCoordinator is laoded\", gameCoordinator);\n}\n\nasync function loadScoreboard() {\n  const responseList = document.getElementById(\"scoreboard\");\n\n  // const response = await fetch(\"https://api.github.com/users/hadley/orgs\");\n  // const jsonData = await response.json();\n  // console.log(jsonData);\n\n  // for (let i = 0; i < jsonData.length; i++) {\n  //   console.log(\"iterating...\", i)\n  //   const name = jsonData[i].login;\n  //   const scoreElements = document.createElement(\"div\");\n  //   scoreElements.innerHTML = `<a>${name}</a>`;\n  //   responseList.appendChild(scoreElements);\n  // }\n\n  for (let i = 0; i < 100; i++) {\n    const userName = \"Wotori\";\n    const scoreElements = document.createElement(\"div\");\n    scoreElements.innerHTML = `<p style=\"margin: 3px\">${\n      i + 1\n    } - ${userName} - score</p>`;\n    responseList.appendChild(scoreElements);\n  }\n}\n\nwindow.onload = () => {\n  initCoordinator();\n  loadScoreboard();\n};\n","console.log(\"init app.js module...\")\nclass Ghost {\n  constructor(\n    scaledTileSize, mazeArray, pacman, name, level, characterUtil, blinky,\n  ) {\n    this.scaledTileSize = scaledTileSize;\n    this.mazeArray = mazeArray;\n    this.pacman = pacman;\n    this.name = name;\n    this.level = level;\n    this.characterUtil = characterUtil;\n    this.blinky = blinky;\n    this.animationTarget = document.getElementById(name);\n\n    this.reset();\n  }\n\n  /**\n   * Rests the character to its default state\n   * @param {Boolean} fullGameReset\n   */\n  reset(fullGameReset) {\n    if (fullGameReset) {\n      delete this.defaultSpeed;\n      delete this.cruiseElroy;\n    }\n\n    this.setDefaultMode();\n    this.setMovementStats(this.pacman, this.name, this.level);\n    this.setSpriteAnimationStats();\n    this.setStyleMeasurements(this.scaledTileSize, this.spriteFrames);\n    this.setDefaultPosition(this.scaledTileSize, this.name);\n    this.setSpriteSheet(this.name, this.direction, this.mode);\n  }\n\n  /**\n   * Sets the default mode and idleMode behavior\n   */\n  setDefaultMode() {\n    this.allowCollision = true;\n    this.defaultMode = 'scatter';\n    this.mode = 'scatter';\n    if (this.name !== 'blinky') {\n      this.idleMode = 'idle';\n    }\n  }\n\n  /**\n   * Sets various properties related to the ghost's movement\n   * @param {Object} pacman - Pacman's speed is used as the base for the ghosts' speeds\n   * @param {('inky'|'blinky'|'pinky'|'clyde')} name - The name of the current ghost\n   */\n  setMovementStats(pacman, name, level) {\n    const pacmanSpeed = pacman.velocityPerMs;\n    const levelAdjustment = level / 100;\n\n    this.slowSpeed = pacmanSpeed * (0.75 + levelAdjustment);\n    this.mediumSpeed = pacmanSpeed * (0.875 + levelAdjustment);\n    this.fastSpeed = pacmanSpeed * (1 + levelAdjustment);\n\n    if (!this.defaultSpeed) {\n      this.defaultSpeed = this.slowSpeed;\n    }\n\n    this.scaredSpeed = pacmanSpeed * 0.5;\n    this.transitionSpeed = pacmanSpeed * 0.4;\n    this.eyeSpeed = pacmanSpeed * 2;\n\n    this.velocityPerMs = this.defaultSpeed;\n    this.moving = false;\n\n    switch (name) {\n      case 'blinky':\n        this.defaultDirection = this.characterUtil.directions.left;\n        break;\n      case 'pinky':\n        this.defaultDirection = this.characterUtil.directions.down;\n        break;\n      case 'inky':\n        this.defaultDirection = this.characterUtil.directions.up;\n        break;\n      case 'clyde':\n        this.defaultDirection = this.characterUtil.directions.up;\n        break;\n      default:\n        this.defaultDirection = this.characterUtil.directions.left;\n        break;\n    }\n    this.direction = this.defaultDirection;\n  }\n\n  /**\n   * Sets values pertaining to the ghost's spritesheet animation\n   */\n  setSpriteAnimationStats() {\n    this.display = true;\n    this.loopAnimation = true;\n    this.animate = true;\n    this.msBetweenSprites = 250;\n    this.msSinceLastSprite = 0;\n    this.spriteFrames = 2;\n    this.backgroundOffsetPixels = 0;\n    this.animationTarget.style.backgroundPosition = '0px 0px';\n  }\n\n  /**\n   * Sets css property values for the ghost\n   * @param {number} scaledTileSize - The dimensions of a single tile\n   * @param {number} spriteFrames - The number of frames in the ghost's spritesheet\n   */\n  setStyleMeasurements(scaledTileSize, spriteFrames) {\n    // The ghosts are the size of 2x2 game tiles.\n    this.measurement = scaledTileSize * 2;\n\n    this.animationTarget.style.height = `${this.measurement}px`;\n    this.animationTarget.style.width = `${this.measurement}px`;\n    const bgSize = this.measurement * spriteFrames;\n    this.animationTarget.style.backgroundSize = `${bgSize}px`;\n  }\n\n  /**\n   * Sets the default position and direction for the ghosts at the game's start\n   * @param {number} scaledTileSize - The dimensions of a single tile\n   * @param {('inky'|'blinky'|'pinky'|'clyde')} name - The name of the current ghost\n   */\n  setDefaultPosition(scaledTileSize, name) {\n    switch (name) {\n      case 'blinky':\n        this.defaultPosition = {\n          top: scaledTileSize * 10.5,\n          left: scaledTileSize * 13,\n        };\n        break;\n      case 'pinky':\n        this.defaultPosition = {\n          top: scaledTileSize * 13.5,\n          left: scaledTileSize * 13,\n        };\n        break;\n      case 'inky':\n        this.defaultPosition = {\n          top: scaledTileSize * 13.5,\n          left: scaledTileSize * 11,\n        };\n        break;\n      case 'clyde':\n        this.defaultPosition = {\n          top: scaledTileSize * 13.5,\n          left: scaledTileSize * 15,\n        };\n        break;\n      default:\n        this.defaultPosition = {\n          top: 0,\n          left: 0,\n        };\n        break;\n    }\n    this.position = Object.assign({}, this.defaultPosition);\n    this.oldPosition = Object.assign({}, this.position);\n    this.animationTarget.style.top = `${this.position.top}px`;\n    this.animationTarget.style.left = `${this.position.left}px`;\n  }\n\n  /**\n   * Chooses a movement Spritesheet depending upon direction\n   * @param {('inky'|'blinky'|'pinky'|'clyde')} name - The name of the current ghost\n   * @param {('up'|'down'|'left'|'right')} direction - The character's current travel orientation\n   * @param {('chase'|'scatter'|'scared'|'eyes')} mode - The character's behavior mode\n   */\n  setSpriteSheet(name, direction, mode) {\n    let emotion = '';\n    if (this.defaultSpeed !== this.slowSpeed) {\n      emotion = (this.defaultSpeed === this.mediumSpeed)\n        ? '_annoyed' : '_angry';\n    }\n\n    if (mode === 'scared') {\n      this.animationTarget.style.backgroundImage = 'url(/style/graphics/'\n        + `spriteSheets/characters/ghosts/scared_${this.scaredColor}.svg)`;\n    } else if (mode === 'eyes') {\n      this.animationTarget.style.backgroundImage = 'url(/style/graphics/'\n        + `spriteSheets/characters/ghosts/eyes_${direction}.svg)`;\n    } else {\n      this.animationTarget.style.backgroundImage = 'url(/style/graphics/'\n        + `spriteSheets/characters/ghosts/${name}/${name}_${direction}`\n        + `${emotion}.svg)`;\n    }\n  }\n\n  /**\n   * Checks to see if the ghost is currently in the 'tunnels' on the outer edges of the maze\n   * @param {({x: number, y: number})} gridPosition - The current x-y position on the 2D Maze Array\n   * @returns {Boolean}\n   */\n  isInTunnel(gridPosition) {\n    return (\n      gridPosition.y === 14\n      && (gridPosition.x < 6 || gridPosition.x > 21)\n    );\n  }\n\n  /**\n   * Checks to see if the ghost is currently in the 'Ghost House' in the center of the maze\n   * @param {({x: number, y: number})} gridPosition - The current x-y position on the 2D Maze Array\n   * @returns {Boolean}\n   */\n  isInGhostHouse(gridPosition) {\n    return (\n      (gridPosition.x > 9 && gridPosition.x < 18)\n      && (gridPosition.y > 11 && gridPosition.y < 17)\n    );\n  }\n\n  /**\n   * Checks to see if the tile at the given coordinates of the Maze is an open position\n   * @param {Array} mazeArray - 2D array representing the game board\n   * @param {number} y - The target row\n   * @param {number} x - The target column\n   * @returns {(false | { x: number, y: number})} - x-y pair if the tile is free, false otherwise\n   */\n  getTile(mazeArray, y, x) {\n    let tile = false;\n\n    if (mazeArray[y] && mazeArray[y][x] && mazeArray[y][x] !== 'X') {\n      tile = {\n        x,\n        y,\n      };\n    }\n\n    return tile;\n  }\n\n  /**\n   * Returns a list of all of the possible moves for the ghost to make on the next turn\n   * @param {({x: number, y: number})} gridPosition - The current x-y position on the 2D Maze Array\n   * @param {('up'|'down'|'left'|'right')} direction - The character's current travel orientation\n   * @param {Array} mazeArray - 2D array representing the game board\n   * @returns {object}\n   */\n  determinePossibleMoves(gridPosition, direction, mazeArray) {\n    const { x, y } = gridPosition;\n\n    const possibleMoves = {\n      up: this.getTile(mazeArray, y - 1, x),\n      down: this.getTile(mazeArray, y + 1, x),\n      left: this.getTile(mazeArray, y, x - 1),\n      right: this.getTile(mazeArray, y, x + 1),\n    };\n\n    // Ghosts are not allowed to turn around at crossroads\n    possibleMoves[this.characterUtil.getOppositeDirection(direction)] = false;\n\n    Object.keys(possibleMoves).forEach((tile) => {\n      if (possibleMoves[tile] === false) {\n        delete possibleMoves[tile];\n      }\n    });\n\n    return possibleMoves;\n  }\n\n  /**\n   * Uses the Pythagorean Theorem to measure the distance between a given postion and Pacman\n   * @param {({x: number, y: number})} position - An x-y position on the 2D Maze Array\n   * @param {({x: number, y: number})} pacman - Pacman's current x-y position on the 2D Maze Array\n   * @returns {number}\n   */\n  calculateDistance(position, pacman) {\n    return Math.sqrt(\n      ((position.x - pacman.x) ** 2) + ((position.y - pacman.y) ** 2),\n    );\n  }\n\n  /**\n   * Gets a position a number of spaces in front of Pacman's direction\n   * @param {({x: number, y: number})} pacmanGridPosition\n   * @param {number} spaces\n   */\n  getPositionInFrontOfPacman(pacmanGridPosition, spaces) {\n    const target = Object.assign({}, pacmanGridPosition);\n    const pacDirection = this.pacman.direction;\n    const propToChange = (pacDirection === 'up' || pacDirection === 'down')\n      ? 'y' : 'x';\n    const tileOffset = (pacDirection === 'up' || pacDirection === 'left')\n      ? (spaces * -1) : spaces;\n    target[propToChange] += tileOffset;\n\n    return target;\n  }\n\n  /**\n   * Determines Pinky's target, which is four tiles in front of Pacman's direction\n   * @param {({x: number, y: number})} pacmanGridPosition\n   * @returns {({x: number, y: number})}\n   */\n  determinePinkyTarget(pacmanGridPosition) {\n    return this.getPositionInFrontOfPacman(\n      pacmanGridPosition, 4,\n    );\n  }\n\n  /**\n   * Determines Inky's target, which is a mirror image of Blinky's position\n   * reflected across a point two tiles in front of Pacman's direction.\n   * Example @ app\\style\\graphics\\spriteSheets\\references\\inky_target.png\n   * @param {({x: number, y: number})} pacmanGridPosition\n   * @returns {({x: number, y: number})}\n   */\n  determineInkyTarget(pacmanGridPosition) {\n    const blinkyGridPosition = this.characterUtil.determineGridPosition(\n      this.blinky.position, this.scaledTileSize,\n    );\n    const pivotPoint = this.getPositionInFrontOfPacman(\n      pacmanGridPosition, 2,\n    );\n    return {\n      x: pivotPoint.x + (pivotPoint.x - blinkyGridPosition.x),\n      y: pivotPoint.y + (pivotPoint.y - blinkyGridPosition.y),\n    };\n  }\n\n  /**\n   * Clyde targets Pacman when the two are far apart, but retreats to the\n   * lower-left corner when the two are within eight tiles of each other\n   * @param {({x: number, y: number})} gridPosition\n   * @param {({x: number, y: number})} pacmanGridPosition\n   * @returns {({x: number, y: number})}\n   */\n  determineClydeTarget(gridPosition, pacmanGridPosition) {\n    const distance = this.calculateDistance(gridPosition, pacmanGridPosition);\n    return (distance > 8) ? pacmanGridPosition : { x: 0, y: 30 };\n  }\n\n  /**\n   * Determines the appropriate target for the ghost's AI\n   * @param {('inky'|'blinky'|'pinky'|'clyde')} name - The name of the current ghost\n   * @param {({x: number, y: number})} gridPosition - The current x-y position on the 2D Maze Array\n   * @param {({x: number, y: number})} pacmanGridPosition - x-y position on the 2D Maze Array\n   * @param {('chase'|'scatter'|'scared'|'eyes')} mode - The character's behavior mode\n   * @returns {({x: number, y: number})}\n   */\n  getTarget(name, gridPosition, pacmanGridPosition, mode) {\n    // Ghosts return to the ghost-house after eaten\n    if (mode === 'eyes') {\n      return { x: 13.5, y: 10 };\n    }\n\n    // Ghosts run from Pacman if scared\n    if (mode === 'scared') {\n      return pacmanGridPosition;\n    }\n\n    // Ghosts seek out corners in Scatter mode\n    if (mode === 'scatter') {\n      switch (name) {\n        case 'blinky':\n          // Blinky will chase Pacman, even in Scatter mode, if he's in Cruise Elroy form\n          return (this.cruiseElroy ? pacmanGridPosition : { x: 27, y: 0 });\n        case 'pinky':\n          return { x: 0, y: 0 };\n        case 'inky':\n          return { x: 27, y: 30 };\n        case 'clyde':\n          return { x: 0, y: 30 };\n        default:\n          return { x: 0, y: 0 };\n      }\n    }\n\n    switch (name) {\n      // Blinky goes after Pacman's position\n      case 'blinky':\n        return pacmanGridPosition;\n      case 'pinky':\n        return this.determinePinkyTarget(pacmanGridPosition);\n      case 'inky':\n        return this.determineInkyTarget(pacmanGridPosition);\n      case 'clyde':\n        return this.determineClydeTarget(gridPosition, pacmanGridPosition);\n      default:\n        // TODO: Other ghosts\n        return pacmanGridPosition;\n    }\n  }\n\n  /**\n   * Calls the appropriate function to determine the best move depending on the ghost's name\n   * @param {('inky'|'blinky'|'pinky'|'clyde')} name - The name of the current ghost\n   * @param {Object} possibleMoves - All of the moves the ghost could choose to make this turn\n   * @param {({x: number, y: number})} gridPosition - The current x-y position on the 2D Maze Array\n   * @param {({x: number, y: number})} pacmanGridPosition - x-y position on the 2D Maze Array\n   * @param {('chase'|'scatter'|'scared'|'eyes')} mode - The character's behavior mode\n   * @returns {('up'|'down'|'left'|'right')}\n   */\n  determineBestMove(\n    name, possibleMoves, gridPosition, pacmanGridPosition, mode,\n  ) {\n    let bestDistance = (mode === 'scared') ? 0 : Infinity;\n    let bestMove;\n    const target = this.getTarget(name, gridPosition, pacmanGridPosition, mode);\n\n    Object.keys(possibleMoves).forEach((move) => {\n      const distance = this.calculateDistance(\n        possibleMoves[move], target,\n      );\n      const betterMove = (mode === 'scared')\n        ? (distance > bestDistance)\n        : (distance < bestDistance);\n\n      if (betterMove) {\n        bestDistance = distance;\n        bestMove = move;\n      }\n    });\n\n    return bestMove;\n  }\n\n  /**\n   * Determines the best direction for the ghost to travel in during the current frame\n   * @param {('inky'|'blinky'|'pinky'|'clyde')} name - The name of the current ghost\n   * @param {({x: number, y: number})} gridPosition - The current x-y position on the 2D Maze Array\n   * @param {({x: number, y: number})} pacmanGridPosition - x-y position on the 2D Maze Array\n   * @param {('up'|'down'|'left'|'right')} direction - The character's current travel orientation\n   * @param {Array} mazeArray - 2D array representing the game board\n   * @param {('chase'|'scatter'|'scared'|'eyes')} mode - The character's behavior mode\n   * @returns {('up'|'down'|'left'|'right')}\n   */\n  determineDirection(\n    name, gridPosition, pacmanGridPosition, direction, mazeArray, mode,\n  ) {\n    let newDirection = direction;\n    const possibleMoves = this.determinePossibleMoves(\n      gridPosition, direction, mazeArray,\n    );\n\n    if (Object.keys(possibleMoves).length === 1) {\n      [newDirection] = Object.keys(possibleMoves);\n    } else if (Object.keys(possibleMoves).length > 1) {\n      newDirection = this.determineBestMove(\n        name, possibleMoves, gridPosition, pacmanGridPosition, mode,\n      );\n    }\n\n    return newDirection;\n  }\n\n  /**\n   * Handles movement for idle Ghosts in the Ghost House\n   * @param {*} elapsedMs\n   * @param {*} position\n   * @param {*} velocity\n   * @returns {({ top: number, left: number})}\n   */\n  handleIdleMovement(elapsedMs, position, velocity) {\n    const newPosition = Object.assign({}, this.position);\n\n    if (position.y <= 13.5) {\n      this.direction = this.characterUtil.directions.down;\n    } else if (position.y >= 14.5) {\n      this.direction = this.characterUtil.directions.up;\n    }\n\n    if (this.idleMode === 'leaving') {\n      if (position.x === 13.5 && (position.y > 10.8 && position.y < 11)) {\n        this.idleMode = undefined;\n        newPosition.top = this.scaledTileSize * 10.5;\n        this.direction = this.characterUtil.directions.left;\n        window.dispatchEvent(new Event('releaseGhost'));\n      } else if (position.x > 13.4 && position.x < 13.6) {\n        newPosition.left = this.scaledTileSize * 13;\n        this.direction = this.characterUtil.directions.up;\n      } else if (position.y > 13.9 && position.y < 14.1) {\n        newPosition.top = this.scaledTileSize * 13.5;\n        this.direction = (position.x < 13.5)\n          ? this.characterUtil.directions.right\n          : this.characterUtil.directions.left;\n      }\n    }\n\n    newPosition[this.characterUtil.getPropertyToChange(this.direction)]\n      += this.characterUtil.getVelocity(this.direction, velocity) * elapsedMs;\n\n    return newPosition;\n  }\n\n  /**\n   * Sets idleMode to 'leaving', allowing the ghost to leave the Ghost House\n   */\n  endIdleMode() {\n    this.idleMode = 'leaving';\n  }\n\n  /**\n   * Handle the ghost's movement when it is snapped to the x-y grid of the Maze Array\n   * @param {number} elapsedMs - The amount of MS that have passed since the last update\n   * @param {({x: number, y: number})} gridPosition - x-y position during the current frame\n   * @param {number} velocity - The distance the character should travel in a single millisecond\n   * @param {({x: number, y: number})} pacmanGridPosition - x-y position on the 2D Maze Array\n   * @returns {({ top: number, left: number})}\n   */\n  handleSnappedMovement(elapsedMs, gridPosition, velocity, pacmanGridPosition) {\n    const newPosition = Object.assign({}, this.position);\n\n    this.direction = this.determineDirection(\n      this.name, gridPosition, pacmanGridPosition, this.direction,\n      this.mazeArray, this.mode,\n    );\n    newPosition[this.characterUtil.getPropertyToChange(this.direction)]\n      += this.characterUtil.getVelocity(this.direction, velocity) * elapsedMs;\n\n    return newPosition;\n  }\n\n  /**\n   * Determines if an eaten ghost is at the entrance of the Ghost House\n   * @param {('chase'|'scatter'|'scared'|'eyes')} mode - The character's behavior mode\n   * @param {({x: number, y: number})} position - x-y position during the current frame\n   * @returns {Boolean}\n   */\n  enteringGhostHouse(mode, position) {\n    return (\n      mode === 'eyes'\n      && position.y === 11\n      && (position.x > 13.4 && position.x < 13.6)\n    );\n  }\n\n  /**\n   * Determines if an eaten ghost has reached the center of the Ghost House\n   * @param {('chase'|'scatter'|'scared'|'eyes')} mode - The character's behavior mode\n   * @param {({x: number, y: number})} position - x-y position during the current frame\n   * @returns {Boolean}\n   */\n  enteredGhostHouse(mode, position) {\n    return (\n      mode === 'eyes'\n      && position.x === 13.5\n      && (position.y > 13.8 && position.y < 14.2)\n    );\n  }\n\n  /**\n   * Determines if a restored ghost is at the exit of the Ghost House\n   * @param {('chase'|'scatter'|'scared'|'eyes')} mode - The character's behavior mode\n   * @param {({x: number, y: number})} position - x-y position during the current frame\n   * @returns {Boolean}\n   */\n  leavingGhostHouse(mode, position) {\n    return (\n      mode !== 'eyes'\n      && position.x === 13.5\n      && (position.y > 10.8 && position.y < 11)\n    );\n  }\n\n  /**\n   * Handles entering and leaving the Ghost House after a ghost is eaten\n   * @param {({x: number, y: number})} gridPosition - x-y position during the current frame\n   * @returns {({x: number, y: number})}\n   */\n  handleGhostHouse(gridPosition) {\n    const gridPositionCopy = Object.assign({}, gridPosition);\n\n    if (this.enteringGhostHouse(this.mode, gridPosition)) {\n      this.direction = this.characterUtil.directions.down;\n      gridPositionCopy.x = 13.5;\n      this.position = this.characterUtil.snapToGrid(\n        gridPositionCopy, this.direction, this.scaledTileSize,\n      );\n    }\n\n    if (this.enteredGhostHouse(this.mode, gridPosition)) {\n      this.direction = this.characterUtil.directions.up;\n      gridPositionCopy.y = 14;\n      this.position = this.characterUtil.snapToGrid(\n        gridPositionCopy, this.direction, this.scaledTileSize,\n      );\n      this.mode = this.defaultMode;\n      window.dispatchEvent(new Event('restoreGhost'));\n    }\n\n    if (this.leavingGhostHouse(this.mode, gridPosition)) {\n      gridPositionCopy.y = 11;\n      this.position = this.characterUtil.snapToGrid(\n        gridPositionCopy, this.direction, this.scaledTileSize,\n      );\n      this.direction = this.characterUtil.directions.left;\n    }\n\n    return gridPositionCopy;\n  }\n\n  /**\n   * Handle the ghost's movement when it is inbetween tiles on the x-y grid of the Maze Array\n   * @param {number} elapsedMs - The amount of MS that have passed since the last update\n   * @param {({x: number, y: number})} gridPosition - x-y position during the current frame\n   * @param {number} velocity - The distance the character should travel in a single millisecond\n   * @returns {({ top: number, left: number})}\n   */\n  handleUnsnappedMovement(elapsedMs, gridPosition, velocity) {\n    const gridPositionCopy = this.handleGhostHouse(gridPosition);\n\n    const desired = this.characterUtil.determineNewPositions(\n      this.position, this.direction, velocity, elapsedMs, this.scaledTileSize,\n    );\n\n    if (this.characterUtil.changingGridPosition(\n      gridPositionCopy, desired.newGridPosition,\n    )) {\n      return this.characterUtil.snapToGrid(\n        gridPositionCopy, this.direction, this.scaledTileSize,\n      );\n    }\n\n    return desired.newPosition;\n  }\n\n  /**\n   * Determines the new Ghost position\n   * @param {number} elapsedMs\n   * @returns {({ top: number, left: number})}\n   */\n  handleMovement(elapsedMs) {\n    let newPosition;\n\n    const gridPosition = this.characterUtil.determineGridPosition(\n      this.position, this.scaledTileSize,\n    );\n    const pacmanGridPosition = this.characterUtil.determineGridPosition(\n      this.pacman.position, this.scaledTileSize,\n    );\n    const velocity = this.determineVelocity(\n      gridPosition, this.mode,\n    );\n\n    if (this.idleMode) {\n      newPosition = this.handleIdleMovement(\n        elapsedMs, gridPosition, velocity,\n      );\n    } else if (JSON.stringify(this.position) === JSON.stringify(\n      this.characterUtil.snapToGrid(\n        gridPosition, this.direction, this.scaledTileSize,\n      ),\n    )) {\n      newPosition = this.handleSnappedMovement(\n        elapsedMs, gridPosition, velocity, pacmanGridPosition,\n      );\n    } else {\n      newPosition = this.handleUnsnappedMovement(\n        elapsedMs, gridPosition, velocity,\n      );\n    }\n\n    newPosition = this.characterUtil.handleWarp(\n      newPosition, this.scaledTileSize, this.mazeArray,\n    );\n\n    this.checkCollision(gridPosition, pacmanGridPosition);\n\n    return newPosition;\n  }\n\n  /**\n   * Changes the defaultMode to chase or scatter, and turns the ghost around\n   * if needed\n   * @param {('chase'|'scatter')} newMode\n   */\n  changeMode(newMode) {\n    this.defaultMode = newMode;\n\n    const gridPosition = this.characterUtil.determineGridPosition(\n      this.position, this.scaledTileSize,\n    );\n\n    if ((this.mode === 'chase' || this.mode === 'scatter')\n      && !this.cruiseElroy) {\n      this.mode = newMode;\n\n      if (!this.isInGhostHouse(gridPosition)) {\n        this.direction = this.characterUtil.getOppositeDirection(\n          this.direction,\n        );\n      }\n    }\n  }\n\n  /**\n   * Toggles a scared ghost between blue and white, then updates its spritsheet\n   */\n  toggleScaredColor() {\n    this.scaredColor = (this.scaredColor === 'blue')\n      ? 'white' : 'blue';\n    this.setSpriteSheet(this.name, this.direction, this.mode);\n  }\n\n  /**\n   * Sets the ghost's mode to SCARED, turns the ghost around,\n   * and changes spritesheets accordingly\n   */\n  becomeScared() {\n    const gridPosition = this.characterUtil.determineGridPosition(\n      this.position, this.scaledTileSize,\n    );\n\n    if (this.mode !== 'eyes') {\n      if (!this.isInGhostHouse(gridPosition) && this.mode !== 'scared') {\n        this.direction = this.characterUtil.getOppositeDirection(\n          this.direction,\n        );\n      }\n      this.mode = 'scared';\n      this.scaredColor = 'blue';\n      this.setSpriteSheet(this.name, this.direction, this.mode);\n    }\n  }\n\n  /**\n   * Returns the scared ghost to chase/scatter mode and sets its spritesheet\n   */\n  endScared() {\n    this.mode = this.defaultMode;\n    this.setSpriteSheet(this.name, this.direction, this.mode);\n  }\n\n  /**\n   * Speeds up the ghost (used for Blinky as Pacdots are eaten)\n   */\n  speedUp() {\n    this.cruiseElroy = true;\n\n    if (this.defaultSpeed === this.slowSpeed) {\n      this.defaultSpeed = this.mediumSpeed;\n    } else if (this.defaultSpeed === this.mediumSpeed) {\n      this.defaultSpeed = this.fastSpeed;\n    }\n  }\n\n  /**\n   * Resets defaultSpeed to slow and updates the spritesheet\n   */\n  resetDefaultSpeed() {\n    this.defaultSpeed = this.slowSpeed;\n    this.cruiseElroy = false;\n    this.setSpriteSheet(this.name, this.direction, this.mode);\n  }\n\n  /**\n   * Sets a flag to indicate when the ghost should pause its movement\n   * @param {Boolean} newValue\n   */\n  pause(newValue) {\n    this.paused = newValue;\n  }\n\n  /**\n   * Checks if the ghost contacts Pacman - starts the death sequence if so\n   * @param {({x: number, y: number})} position - An x-y position on the 2D Maze Array\n   * @param {({x: number, y: number})} pacman - Pacman's current x-y position on the 2D Maze Array\n   */\n  checkCollision(position, pacman) {\n    if (this.calculateDistance(position, pacman) < 1\n      && this.mode !== 'eyes'\n      && this.allowCollision) {\n      if (this.mode === 'scared') {\n        window.dispatchEvent(new CustomEvent('eatGhost', {\n          detail: {\n            ghost: this,\n          },\n        }));\n        this.mode = 'eyes';\n      } else {\n        window.dispatchEvent(new Event('deathSequence'));\n      }\n    }\n  }\n\n  /**\n   * Determines the appropriate speed for the ghost\n   * @param {({x: number, y: number})} position - An x-y position on the 2D Maze Array\n   * @param {('chase'|'scatter'|'scared'|'eyes')} mode - The character's behavior mode\n   * @returns {number}\n   */\n  determineVelocity(position, mode) {\n    if (mode === 'eyes') {\n      return this.eyeSpeed;\n    }\n\n    if (this.paused) {\n      return 0;\n    }\n\n    if (this.isInTunnel(position) || this.isInGhostHouse(position)) {\n      return this.transitionSpeed;\n    }\n\n    if (mode === 'scared') {\n      return this.scaredSpeed;\n    }\n\n    return this.defaultSpeed;\n  }\n\n  /**\n   * Updates the css position, hides if there is a stutter, and animates the spritesheet\n   * @param {number} interp - The animation accuracy as a percentage\n   */\n  draw(interp) {\n    const newTop = this.characterUtil.calculateNewDrawValue(\n      interp, 'top', this.oldPosition, this.position,\n    );\n    const newLeft = this.characterUtil.calculateNewDrawValue(\n      interp, 'left', this.oldPosition, this.position,\n    );\n    this.animationTarget.style.top = `${newTop}px`;\n    this.animationTarget.style.left = `${newLeft}px`;\n\n    this.animationTarget.style.visibility = this.display\n      ? this.characterUtil.checkForStutter(this.position, this.oldPosition)\n      : 'hidden';\n\n    const updatedProperties = this.characterUtil.advanceSpriteSheet(this);\n    this.msSinceLastSprite = updatedProperties.msSinceLastSprite;\n    this.animationTarget = updatedProperties.animationTarget;\n    this.backgroundOffsetPixels = updatedProperties.backgroundOffsetPixels;\n  }\n\n  /**\n   * Handles movement logic for the ghost\n   * @param {number} elapsedMs - The amount of MS that have passed since the last update\n   */\n  update(elapsedMs) {\n    this.oldPosition = Object.assign({}, this.position);\n\n    if (this.moving) {\n      this.position = this.handleMovement(elapsedMs);\n      this.setSpriteSheet(this.name, this.direction, this.mode);\n      this.msSinceLastSprite += elapsedMs;\n    }\n  }\n}\n\n\nclass Pacman {\n  constructor(scaledTileSize, mazeArray, characterUtil) {\n    this.scaledTileSize = scaledTileSize;\n    this.mazeArray = mazeArray;\n    this.characterUtil = characterUtil;\n    this.animationTarget = document.getElementById('pacman');\n    this.pacmanArrow = document.getElementById('pacman-arrow');\n\n    this.reset();\n  }\n\n  /**\n   * Rests the character to its default state\n   */\n  reset() {\n    this.setMovementStats(this.scaledTileSize);\n    this.setSpriteAnimationStats();\n    this.setStyleMeasurements(this.scaledTileSize, this.spriteFrames);\n    this.setDefaultPosition(this.scaledTileSize);\n    this.setSpriteSheet(this.direction);\n    this.pacmanArrow.style.backgroundImage = 'url(/style/graphics/'\n      + `spriteSheets/characters/pacman/arrow_${this.direction}.svg)`;\n  }\n\n  /**\n   * Sets various properties related to Pacman's movement\n   * @param {number} scaledTileSize - The dimensions of a single tile\n   */\n  setMovementStats(scaledTileSize) {\n    this.velocityPerMs = this.calculateVelocityPerMs(scaledTileSize);\n    this.desiredDirection = this.characterUtil.directions.left;\n    this.direction = this.characterUtil.directions.left;\n    this.moving = false;\n  }\n\n  /**\n   * Sets values pertaining to Pacman's spritesheet animation\n   */\n  setSpriteAnimationStats() {\n    this.specialAnimation = false;\n    this.display = true;\n    this.animate = true;\n    this.loopAnimation = true;\n    this.msBetweenSprites = 50;\n    this.msSinceLastSprite = 0;\n    this.spriteFrames = 4;\n    this.backgroundOffsetPixels = 0;\n    this.animationTarget.style.backgroundPosition = '0px 0px';\n  }\n\n  /**\n   * Sets css property values for Pacman and Pacman's Arrow\n   * @param {number} scaledTileSize - The dimensions of a single tile\n   * @param {number} spriteFrames - The number of frames in Pacman's spritesheet\n   */\n  setStyleMeasurements(scaledTileSize, spriteFrames) {\n    this.measurement = scaledTileSize * 2;\n\n    this.animationTarget.style.height = `${this.measurement}px`;\n    this.animationTarget.style.width = `${this.measurement}px`;\n    this.animationTarget.style.backgroundSize = `${\n      this.measurement * spriteFrames\n    }px`;\n\n    this.pacmanArrow.style.height = `${this.measurement * 2}px`;\n    this.pacmanArrow.style.width = `${this.measurement * 2}px`;\n    this.pacmanArrow.style.backgroundSize = `${this.measurement * 2}px`;\n  }\n\n  /**\n   * Sets the default position and direction for Pacman at the game's start\n   * @param {number} scaledTileSize - The dimensions of a single tile\n   */\n  setDefaultPosition(scaledTileSize) {\n    this.defaultPosition = {\n      top: scaledTileSize * 22.5,\n      left: scaledTileSize * 13,\n    };\n    this.position = Object.assign({}, this.defaultPosition);\n    this.oldPosition = Object.assign({}, this.position);\n    this.animationTarget.style.top = `${this.position.top}px`;\n    this.animationTarget.style.left = `${this.position.left}px`;\n  }\n\n  /**\n   * Calculates how fast Pacman should move in a millisecond\n   * @param {number} scaledTileSize - The dimensions of a single tile\n   */\n  calculateVelocityPerMs(scaledTileSize) {\n    // In the original game, Pacman moved at 11 tiles per second.\n    const velocityPerSecond = scaledTileSize * 11;\n    return velocityPerSecond / 1000;\n  }\n\n  /**\n   * Chooses a movement Spritesheet depending upon direction\n   * @param {('up'|'down'|'left'|'right')} direction - The character's current travel orientation\n   */\n  setSpriteSheet(direction) {\n    this.animationTarget.style.backgroundImage = 'url(/style/graphics/'\n      + `spriteSheets/characters/pacman/pacman_${direction}.svg)`;\n  }\n\n  prepDeathAnimation() {\n    this.loopAnimation = false;\n    this.msBetweenSprites = 125;\n    this.spriteFrames = 12;\n    this.specialAnimation = true;\n    this.backgroundOffsetPixels = 0;\n    const bgSize = this.measurement * this.spriteFrames;\n    this.animationTarget.style.backgroundSize = `${bgSize}px`;\n    this.animationTarget.style.backgroundImage = 'url(/style/'\n      + 'graphics/spriteSheets/characters/pacman/pacman_death.svg)';\n    this.animationTarget.style.backgroundPosition = '0px 0px';\n    this.pacmanArrow.style.backgroundImage = '';\n  }\n\n  /**\n   * Changes Pacman's desiredDirection, updates the PacmanArrow sprite, and sets moving to true\n   * @param {Event} e - The keydown event to evaluate\n   * @param {Boolean} startMoving - If true, Pacman will move upon key press\n   */\n  changeDirection(newDirection, startMoving) {\n    this.desiredDirection = newDirection;\n    this.pacmanArrow.style.backgroundImage = 'url(/style/graphics/'\n      + `spriteSheets/characters/pacman/arrow_${this.desiredDirection}.svg)`;\n\n    if (startMoving) {\n      this.moving = true;\n    }\n  }\n\n  /**\n   * Updates the position of the leading arrow in front of Pacman\n   * @param {({top: number, left: number})} position - Pacman's position during the current frame\n   * @param {number} scaledTileSize - The dimensions of a single tile\n   */\n  updatePacmanArrowPosition(position, scaledTileSize) {\n    this.pacmanArrow.style.top = `${position.top - scaledTileSize}px`;\n    this.pacmanArrow.style.left = `${position.left - scaledTileSize}px`;\n  }\n\n  /**\n   * Handle Pacman's movement when he is snapped to the x-y grid of the Maze Array\n   * @param {number} elapsedMs - The amount of MS that have passed since the last update\n   * @returns {({ top: number, left: number})}\n   */\n  handleSnappedMovement(elapsedMs) {\n    const desired = this.characterUtil.determineNewPositions(\n      this.position, this.desiredDirection, this.velocityPerMs,\n      elapsedMs, this.scaledTileSize,\n    );\n    const alternate = this.characterUtil.determineNewPositions(\n      this.position, this.direction, this.velocityPerMs,\n      elapsedMs, this.scaledTileSize,\n    );\n\n    if (this.characterUtil.checkForWallCollision(\n      desired.newGridPosition, this.mazeArray, this.desiredDirection,\n    )) {\n      if (this.characterUtil.checkForWallCollision(\n        alternate.newGridPosition, this.mazeArray, this.direction,\n      )) {\n        this.moving = false;\n        return this.position;\n      }\n      return alternate.newPosition;\n    }\n    this.direction = this.desiredDirection;\n    this.setSpriteSheet(this.direction);\n    return desired.newPosition;\n  }\n\n  /**\n   * Handle Pacman's movement when he is inbetween tiles on the x-y grid of the Maze Array\n   * @param {({x: number, y: number})} gridPosition - x-y position during the current frame\n   * @param {number} elapsedMs - The amount of MS that have passed since the last update\n   * @returns {({ top: number, left: number})}\n   */\n  handleUnsnappedMovement(gridPosition, elapsedMs) {\n    const desired = this.characterUtil.determineNewPositions(\n      this.position, this.desiredDirection, this.velocityPerMs,\n      elapsedMs, this.scaledTileSize,\n    );\n    const alternate = this.characterUtil.determineNewPositions(\n      this.position, this.direction, this.velocityPerMs,\n      elapsedMs, this.scaledTileSize,\n    );\n\n    if (this.characterUtil.turningAround(\n      this.direction, this.desiredDirection,\n    )) {\n      this.direction = this.desiredDirection;\n      this.setSpriteSheet(this.direction);\n      return desired.newPosition;\n    } if (this.characterUtil.changingGridPosition(\n      gridPosition, alternate.newGridPosition,\n    )) {\n      return this.characterUtil.snapToGrid(\n        gridPosition, this.direction, this.scaledTileSize,\n      );\n    }\n    return alternate.newPosition;\n  }\n\n  /**\n   * Updates the css position, hides if there is a stutter, and animates the spritesheet\n   * @param {number} interp - The animation accuracy as a percentage\n   */\n  draw(interp) {\n    const newTop = this.characterUtil.calculateNewDrawValue(\n      interp, 'top', this.oldPosition, this.position,\n    );\n    const newLeft = this.characterUtil.calculateNewDrawValue(\n      interp, 'left', this.oldPosition, this.position,\n    );\n    this.animationTarget.style.top = `${newTop}px`;\n    this.animationTarget.style.left = `${newLeft}px`;\n\n    this.animationTarget.style.visibility = this.display\n      ? this.characterUtil.checkForStutter(this.position, this.oldPosition)\n      : 'hidden';\n    this.pacmanArrow.style.visibility = this.animationTarget.style.visibility;\n\n    this.updatePacmanArrowPosition(this.position, this.scaledTileSize);\n\n    const updatedProperties = this.characterUtil.advanceSpriteSheet(this);\n    this.msSinceLastSprite = updatedProperties.msSinceLastSprite;\n    this.animationTarget = updatedProperties.animationTarget;\n    this.backgroundOffsetPixels = updatedProperties.backgroundOffsetPixels;\n  }\n\n  /**\n   * Handles movement logic for Pacman\n   * @param {number} elapsedMs - The amount of MS that have passed since the last update\n   */\n  update(elapsedMs) {\n    this.oldPosition = Object.assign({}, this.position);\n\n    if (this.moving) {\n      const gridPosition = this.characterUtil.determineGridPosition(\n        this.position, this.scaledTileSize,\n      );\n\n      if (JSON.stringify(this.position) === JSON.stringify(\n        this.characterUtil.snapToGrid(\n          gridPosition, this.direction, this.scaledTileSize,\n        ),\n      )) {\n        this.position = this.handleSnappedMovement(elapsedMs);\n      } else {\n        this.position = this.handleUnsnappedMovement(gridPosition, elapsedMs);\n      }\n\n      this.position = this.characterUtil.handleWarp(\n        this.position, this.scaledTileSize, this.mazeArray,\n      );\n    }\n\n    if (this.moving || this.specialAnimation) {\n      this.msSinceLastSprite += elapsedMs;\n    }\n  }\n}\n\n\nexport class GameCoordinator {\n  constructor() {\n    this.gameUi = document.getElementById('game-ui');\n    this.rowTop = document.getElementById('row-top');\n    this.mazeDiv = document.getElementById('maze');\n    this.mazeImg = document.getElementById('maze-img');\n    this.mazeCover = document.getElementById('maze-cover');\n    this.pointsDisplay = document.getElementById('points-display');\n    this.highScoreDisplay = document.getElementById('high-score-display');\n    this.extraLivesDisplay = document.getElementById('extra-lives');\n    this.fruitDisplay = document.getElementById('fruit-display');\n    this.mainMenu = document.getElementById('main-menu-container');\n    this.gameStartButton = document.getElementById('game-start');\n    this.pauseButton = document.getElementById('pause-button');\n    this.soundButton = document.getElementById('sound-button');\n    this.leftCover = document.getElementById('left-cover');\n    this.rightCover = document.getElementById('right-cover');\n    this.pausedText = document.getElementById('paused-text');\n    this.bottomRow = document.getElementById('bottom-row');\n    this.movementButtons = document.getElementById('movement-buttons');\n\n    this.mazeArray = [\n      ['XXXXXXXXXXXXXXXXXXXXXXXXXXXX'],\n      ['XooooooooooooXXooooooooooooX'],\n      ['XoXXXXoXXXXXoXXoXXXXXoXXXXoX'],\n      ['XOXXXXoXXXXXoXXoXXXXXoXXXXOX'],\n      ['XoXXXXoXXXXXoXXoXXXXXoXXXXoX'],\n      ['XooooooooooooooooooooooooooX'],\n      ['XoXXXXoXXoXXXXXXXXoXXoXXXXoX'],\n      ['XoXXXXoXXoXXXXXXXXoXXoXXXXoX'],\n      ['XooooooXXooooXXooooXXooooooX'],\n      ['XXXXXXoXXXXX XX XXXXXoXXXXXX'],\n      ['XXXXXXoXXXXX XX XXXXXoXXXXXX'],\n      ['XXXXXXoXX          XXoXXXXXX'],\n      ['XXXXXXoXX XXXXXXXX XXoXXXXXX'],\n      ['XXXXXXoXX X      X XXoXXXXXX'],\n      ['      o   X      X   o      '],\n      ['XXXXXXoXX X      X XXoXXXXXX'],\n      ['XXXXXXoXX XXXXXXXX XXoXXXXXX'],\n      ['XXXXXXoXX          XXoXXXXXX'],\n      ['XXXXXXoXX XXXXXXXX XXoXXXXXX'],\n      ['XXXXXXoXX XXXXXXXX XXoXXXXXX'],\n      ['XooooooooooooXXooooooooooooX'],\n      ['XoXXXXoXXXXXoXXoXXXXXoXXXXoX'],\n      ['XoXXXXoXXXXXoXXoXXXXXoXXXXoX'],\n      ['XOooXXooooooo  oooooooXXooOX'],\n      ['XXXoXXoXXoXXXXXXXXoXXoXXoXXX'],\n      ['XXXoXXoXXoXXXXXXXXoXXoXXoXXX'],\n      ['XooooooXXooooXXooooXXooooooX'],\n      ['XoXXXXXXXXXXoXXoXXXXXXXXXXoX'],\n      ['XoXXXXXXXXXXoXXoXXXXXXXXXXoX'],\n      ['XooooooooooooooooooooooooooX'],\n      ['XXXXXXXXXXXXXXXXXXXXXXXXXXXX'],\n    ];\n\n    this.maxFps = 120;\n    this.tileSize = 8;\n    this.scale = this.determineScale(1);\n    this.scaledTileSize = this.tileSize * this.scale;\n    this.firstGame = true;\n\n    this.movementKeys = {\n      // WASD\n      87: 'up',\n      83: 'down',\n      65: 'left',\n      68: 'right',\n\n      // Arrow Keys\n      38: 'up',\n      40: 'down',\n      37: 'left',\n      39: 'right',\n    };\n\n    this.fruitPoints = {\n      1: 100,\n      2: 300,\n      3: 500,\n      4: 700,\n      5: 1000,\n      6: 2000,\n      7: 3000,\n      8: 5000,\n    };\n\n    this.mazeArray.forEach((row, rowIndex) => {\n      this.mazeArray[rowIndex] = row[0].split('');\n    });\n\n    this.gameStartButton.addEventListener(\n      'click',\n      this.startButtonClick.bind(this),\n    );\n    this.pauseButton.addEventListener('click', this.handlePauseKey.bind(this));\n    this.soundButton.addEventListener(\n      'click',\n      this.soundButtonClick.bind(this),\n    );\n\n    setTimeout(() => {\n      this.preloadAssets();\n    }, 100);\n  }\n\n  /**\n   * Recursive method which determines the largest possible scale the game's graphics can use\n   * @param {Number} scale\n   */\n  determineScale(scale) {\n    const availableScreenHeight = Math.min(\n      document.documentElement.clientHeight,\n      window.innerHeight || 0,\n    );\n    const availableScreenWidth = Math.min(\n      document.documentElement.clientWidth,\n      window.innerWidth || 0,\n    );\n    const scaledTileSize = this.tileSize * scale;\n\n    // The original Pac-Man game leaves 5 tiles of height (3 above, 2 below) surrounding the\n    // maze for the UI. See app\\style\\graphics\\spriteSheets\\references\\mazeGridSystemReference.png\n    // for reference.\n    const mazeTileHeight = this.mazeArray.length + 5;\n    const mazeTileWidth = this.mazeArray[0][0].split('').length;\n\n    if (\n      scaledTileSize * mazeTileHeight < availableScreenHeight\n      && scaledTileSize * mazeTileWidth < availableScreenWidth\n    ) {\n      return this.determineScale(scale + 1);\n    }\n\n    return scale - 1;\n  }\n\n  /**\n   * Reveals the game underneath the loading covers and starts gameplay\n   */\n  startButtonClick() {\n    console.log(\"clicked\") // TODO: add execute smart contract here....\n    this.leftCover.style.left = '-50%';\n    this.rightCover.style.right = '-50%';\n    this.mainMenu.style.opacity = 0;\n    this.gameStartButton.disabled = true;\n\n    setTimeout(() => {\n      this.mainMenu.style.visibility = 'hidden';\n    }, 1000);\n\n    this.reset();\n    if (this.firstGame) {\n      this.firstGame = false;\n      this.init();\n    }\n    this.startGameplay(true);\n  }\n\n  /**\n   * Toggles the master volume for the soundManager, and saves the preference to storage\n   */\n  soundButtonClick() {\n    const newVolume = this.soundManager.masterVolume === 1 ? 0 : 1;\n    this.soundManager.setMasterVolume(newVolume);\n    localStorage.setItem('volumePreference', newVolume);\n    this.setSoundButtonIcon(newVolume);\n  }\n\n  /**\n   * Sets the icon for the sound button\n   */\n  setSoundButtonIcon(newVolume) {\n    this.soundButton.innerHTML = newVolume === 0 ? 'volume_off' : 'volume_up';\n  }\n\n  /**\n   * Displays an error message in the event assets are unable to download\n   */\n  displayErrorMessage() {\n    console.log(\"display error message\")\n    const loadingContainer = document.getElementById('loading-container');\n    const errorMessage = document.getElementById('error-message');\n    loadingContainer.style.opacity = 0;\n    setTimeout(() => {\n      loadingContainer.remove();\n      errorMessage.style.opacity = 1;\n      errorMessage.style.visibility = 'visible';\n    }, 1500);\n  }\n\n  /**\n   * Load all assets into a hidden Div to pre-load them into memory.\n   * There is probably a better way to read all of these file names.\n   */\n  preloadAssets() {\n    console.log(\"preload assets...\")\n    return new Promise((resolve) => {\n      const loadingContainer = document.getElementById('loading-container');\n      const loadingPacman = document.getElementById('loading-pacman');\n      const loadingDotMask = document.getElementById('loading-dot-mask');\n\n      const imgBase = '/style/graphics/spriteSheets/';\n      const imgSources = [\n        // Pacman\n        `${imgBase}characters/pacman/arrow_down.svg`,\n        `${imgBase}characters/pacman/arrow_left.svg`,\n        `${imgBase}characters/pacman/arrow_right.svg`,\n        `${imgBase}characters/pacman/arrow_up.svg`,\n        `${imgBase}characters/pacman/pacman_death.svg`,\n        `${imgBase}characters/pacman/pacman_error.svg`,\n        `${imgBase}characters/pacman/pacman_down.svg`,\n        `${imgBase}characters/pacman/pacman_left.svg`,\n        `${imgBase}characters/pacman/pacman_right.svg`,\n        `${imgBase}characters/pacman/pacman_up.svg`,\n\n        // Blinky\n        `${imgBase}characters/ghosts/blinky/blinky_down_angry.svg`,\n        `${imgBase}characters/ghosts/blinky/blinky_down_annoyed.svg`,\n        `${imgBase}characters/ghosts/blinky/blinky_down.svg`,\n        `${imgBase}characters/ghosts/blinky/blinky_left_angry.svg`,\n        `${imgBase}characters/ghosts/blinky/blinky_left_annoyed.svg`,\n        `${imgBase}characters/ghosts/blinky/blinky_left.svg`,\n        `${imgBase}characters/ghosts/blinky/blinky_right_angry.svg`,\n        `${imgBase}characters/ghosts/blinky/blinky_right_annoyed.svg`,\n        `${imgBase}characters/ghosts/blinky/blinky_right.svg`,\n        `${imgBase}characters/ghosts/blinky/blinky_up_angry.svg`,\n        `${imgBase}characters/ghosts/blinky/blinky_up_annoyed.svg`,\n        `${imgBase}characters/ghosts/blinky/blinky_up.svg`,\n\n        // Clyde\n        `${imgBase}characters/ghosts/clyde/clyde_down.svg`,\n        `${imgBase}characters/ghosts/clyde/clyde_left.svg`,\n        `${imgBase}characters/ghosts/clyde/clyde_right.svg`,\n        `${imgBase}characters/ghosts/clyde/clyde_up.svg`,\n\n        // Inky\n        `${imgBase}characters/ghosts/inky/inky_down.svg`,\n        `${imgBase}characters/ghosts/inky/inky_left.svg`,\n        `${imgBase}characters/ghosts/inky/inky_right.svg`,\n        `${imgBase}characters/ghosts/inky/inky_up.svg`,\n\n        // Pinky\n        `${imgBase}characters/ghosts/pinky/pinky_down.svg`,\n        `${imgBase}characters/ghosts/pinky/pinky_left.svg`,\n        `${imgBase}characters/ghosts/pinky/pinky_right.svg`,\n        `${imgBase}characters/ghosts/pinky/pinky_up.svg`,\n\n        // Ghosts Common\n        `${imgBase}characters/ghosts/eyes_down.svg`,\n        `${imgBase}characters/ghosts/eyes_left.svg`,\n        `${imgBase}characters/ghosts/eyes_right.svg`,\n        `${imgBase}characters/ghosts/eyes_up.svg`,\n        `${imgBase}characters/ghosts/scared_blue.svg`,\n        `${imgBase}characters/ghosts/scared_white.svg`,\n\n        // Dots\n        `${imgBase}pickups/pacdot.svg`,\n        `${imgBase}pickups/powerPellet.svg`,\n\n        // Fruit\n        `${imgBase}pickups/apple.svg`,\n        `${imgBase}pickups/bell.svg`,\n        `${imgBase}pickups/cherry.svg`,\n        `${imgBase}pickups/galaxian.svg`,\n        `${imgBase}pickups/key.svg`,\n        `${imgBase}pickups/melon.svg`,\n        `${imgBase}pickups/orange.svg`,\n        `${imgBase}pickups/strawberry.svg`,\n\n        // Text\n        `${imgBase}text/ready.svg`,\n\n        // Points\n        `${imgBase}text/100.svg`,\n        `${imgBase}text/200.svg`,\n        `${imgBase}text/300.svg`,\n        `${imgBase}text/400.svg`,\n        `${imgBase}text/500.svg`,\n        `${imgBase}text/700.svg`,\n        `${imgBase}text/800.svg`,\n        `${imgBase}text/1000.svg`,\n        `${imgBase}text/1600.svg`,\n        `${imgBase}text/2000.svg`,\n        `${imgBase}text/3000.svg`,\n        `${imgBase}text/5000.svg`,\n\n        // Maze\n        `${imgBase}maze/maze_blue.svg`,\n\n        // Misc\n        '/style/graphics/extra_life.png',\n      ];\n\n      const audioBase = '/style/audio/';\n      const audioSources = [\n        `${audioBase}game_start.mp3`,\n        `${audioBase}pause.mp3`,\n        `${audioBase}pause_beat.mp3`,\n        `${audioBase}siren_1.mp3`,\n        `${audioBase}siren_2.mp3`,\n        `${audioBase}siren_3.mp3`,\n        `${audioBase}power_up.mp3`,\n        `${audioBase}extra_life.mp3`,\n        `${audioBase}eyes.mp3`,\n        `${audioBase}eat_ghost.mp3`,\n        `${audioBase}death.mp3`,\n        `${audioBase}fruit.mp3`,\n        `${audioBase}dot_1.mp3`,\n        `${audioBase}dot_2.mp3`,\n      ];\n\n      const totalSources = imgSources.length + audioSources.length;\n      this.remainingSources = totalSources;\n\n      loadingPacman.style.left = '0';\n      loadingDotMask.style.width = '0';\n\n      Promise.all([\n        this.createElements(imgSources, 'img', totalSources, this),\n        this.createElements(audioSources, 'audio', totalSources, this),\n      ])\n        .then(() => {\n          loadingContainer.style.opacity = 0;\n          resolve();\n\n          setTimeout(() => {\n            loadingContainer.remove();\n            this.mainMenu.style.opacity = 1;\n            this.mainMenu.style.visibility = 'visible';\n          }, 1500);\n        })\n        .catch((e)=> {\n          console.log(\"load error:\", e)\n          this.displayErrorMessage();\n        });\n    });\n  }\n\n  /**\n   * Iterates through a list of sources and updates the loading bar as the assets load in\n   * @param {String[]} sources\n   * @param {('img'|'audio')} type\n   * @param {Number} totalSources\n   * @param {Object} gameCoord\n   * @returns {Promise}\n   */\n  createElements(sources, type, totalSources, gameCoord) {\n    const loadingContainer = document.getElementById('loading-container');\n    const preloadDiv = document.getElementById('preload-div');\n    const loadingPacman = document.getElementById('loading-pacman');\n    const containerWidth = loadingContainer.scrollWidth\n      - loadingPacman.scrollWidth;\n    const loadingDotMask = document.getElementById('loading-dot-mask');\n\n    const gameCoordRef = gameCoord;\n\n    return new Promise((resolve, reject) => {\n      let loadedSources = 0;\n\n      sources.forEach((source) => {\n        const element = type === 'img' ? new Image() : new Audio();\n        preloadDiv.appendChild(element);\n\n        const elementReady = () => {\n          gameCoordRef.remainingSources -= 1;\n          loadedSources += 1;\n          const percent = 1 - gameCoordRef.remainingSources / totalSources;\n          loadingPacman.style.left = `${percent * containerWidth}px`;\n          loadingDotMask.style.width = loadingPacman.style.left;\n\n          if (loadedSources === sources.length) {\n            resolve();\n          }\n        };\n\n        if (type === 'img') {\n          element.onload = elementReady;\n          element.onerror = reject;\n        } else {\n          element.addEventListener('canplaythrough', elementReady);\n          element.onerror = reject;\n        }\n\n        element.src = source;\n\n        if (type === 'audio') {\n          element.load();\n        }\n      });\n    });\n  }\n\n  /**\n   * Resets gameCoordinator values to their default states\n   */\n  reset() {\n    this.activeTimers = [];\n    this.points = 0;\n    this.level = 1;\n    this.lives = 2;\n    this.extraLifeGiven = false;\n    this.remainingDots = 0;\n    this.allowKeyPresses = true;\n    this.allowPacmanMovement = false;\n    this.allowPause = false;\n    this.cutscene = true;\n    this.highScore = localStorage.getItem('highScore');\n\n    if (this.firstGame) {\n      setInterval(() => {\n        this.collisionDetectionLoop();\n      }, 500);\n\n      this.pacman = new Pacman(\n        this.scaledTileSize,\n        this.mazeArray,\n        new CharacterUtil(),\n      );\n      this.blinky = new Ghost(\n        this.scaledTileSize,\n        this.mazeArray,\n        this.pacman,\n        'blinky',\n        this.level,\n        new CharacterUtil(),\n      );\n      this.pinky = new Ghost(\n        this.scaledTileSize,\n        this.mazeArray,\n        this.pacman,\n        'pinky',\n        this.level,\n        new CharacterUtil(),\n      );\n      this.inky = new Ghost(\n        this.scaledTileSize,\n        this.mazeArray,\n        this.pacman,\n        'inky',\n        this.level,\n        new CharacterUtil(),\n        this.blinky,\n      );\n      this.clyde = new Ghost(\n        this.scaledTileSize,\n        this.mazeArray,\n        this.pacman,\n        'clyde',\n        this.level,\n        new CharacterUtil(),\n      );\n      this.fruit = new Pickup(\n        'fruit',\n        this.scaledTileSize,\n        13.5,\n        17,\n        this.pacman,\n        this.mazeDiv,\n        100,\n      );\n    }\n\n    this.entityList = [\n      this.pacman,\n      this.blinky,\n      this.pinky,\n      this.inky,\n      this.clyde,\n      this.fruit,\n    ];\n\n    this.ghosts = [this.blinky, this.pinky, this.inky, this.clyde];\n\n    this.scaredGhosts = [];\n    this.eyeGhosts = 0;\n\n    if (this.firstGame) {\n      this.drawMaze(this.mazeArray, this.entityList);\n      this.soundManager = new SoundManager();\n      this.setUiDimensions();\n    } else {\n      this.pacman.reset();\n      this.ghosts.forEach((ghost) => {\n        ghost.reset(true);\n      });\n      this.pickups.forEach((pickup) => {\n        if (pickup.type !== 'fruit') {\n          this.remainingDots += 1;\n          pickup.reset();\n          this.entityList.push(pickup);\n        }\n      });\n    }\n\n    this.pointsDisplay.innerHTML = '00';\n    this.highScoreDisplay.innerHTML = this.highScore || '00';\n    this.clearDisplay(this.fruitDisplay);\n\n    const volumePreference = parseInt(\n      localStorage.getItem('volumePreference') || 1,\n      10,\n    );\n    this.setSoundButtonIcon(volumePreference);\n    this.soundManager.setMasterVolume(volumePreference);\n  }\n\n  /**\n   * Calls necessary setup functions to start the game\n   */\n  init() {\n    this.registerEventListeners();\n\n    this.gameEngine = new GameEngine(this.maxFps, this.entityList);\n    this.gameEngine.start();\n  }\n\n  /**\n   * Adds HTML elements to draw on the webpage by iterating through the 2D maze array\n   * @param {Array} mazeArray - 2D array representing the game board\n   * @param {Array} entityList - List of entities to be used throughout the game\n   */\n  drawMaze(mazeArray, entityList) {\n    this.pickups = [this.fruit];\n\n    this.mazeDiv.style.height = `${this.scaledTileSize * 31}px`;\n    this.mazeDiv.style.width = `${this.scaledTileSize * 28}px`;\n    this.gameUi.style.width = `${this.scaledTileSize * 28}px`;\n    this.bottomRow.style.minHeight = `${this.scaledTileSize * 2}px`;\n    this.dotContainer = document.getElementById('dot-container');\n\n    mazeArray.forEach((row, rowIndex) => {\n      row.forEach((block, columnIndex) => {\n        if (block === 'o' || block === 'O') {\n          const type = block === 'o' ? 'pacdot' : 'powerPellet';\n          const points = block === 'o' ? 10 : 50;\n          const dot = new Pickup(\n            type,\n            this.scaledTileSize,\n            columnIndex,\n            rowIndex,\n            this.pacman,\n            this.dotContainer,\n            points,\n          );\n\n          entityList.push(dot);\n          this.pickups.push(dot);\n          this.remainingDots += 1;\n        }\n      });\n    });\n  }\n\n  setUiDimensions() {\n    this.gameUi.style.fontSize = `${this.scaledTileSize}px`;\n    this.rowTop.style.marginBottom = `${this.scaledTileSize}px`;\n  }\n\n  /**\n   * Loop which periodically checks which pickups are nearby Pacman.\n   * Pickups which are far away will not be considered for collision detection.\n   */\n  collisionDetectionLoop() {\n    if (this.pacman.position) {\n      const maxDistance = this.pacman.velocityPerMs * 750;\n      const pacmanCenter = {\n        x: this.pacman.position.left + this.scaledTileSize,\n        y: this.pacman.position.top + this.scaledTileSize,\n      };\n\n      // Set this flag to TRUE to see how two-phase collision detection works!\n      const debugging = false;\n\n      this.pickups.forEach((pickup) => {\n        pickup.checkPacmanProximity(maxDistance, pacmanCenter, debugging);\n      });\n    }\n  }\n\n  /**\n   * Displays \"Ready!\" and allows Pacman to move after a breif delay\n   * @param {Boolean} initialStart - Special condition for the game's beginning\n   */\n  startGameplay(initialStart) {\n    if (initialStart) {\n      this.soundManager.play('game_start');\n    }\n\n    this.scaredGhosts = [];\n    this.eyeGhosts = 0;\n    this.allowPacmanMovement = false;\n\n    const left = this.scaledTileSize * 11;\n    const top = this.scaledTileSize * 16.5;\n    const duration = initialStart ? 4500 : 2000;\n    const width = this.scaledTileSize * 6;\n    const height = this.scaledTileSize * 2;\n\n    this.displayText({ left, top }, 'ready', duration, width, height);\n    this.updateExtraLivesDisplay();\n\n    new Timer(() => {\n      this.allowPause = true;\n      this.cutscene = false;\n      this.soundManager.setCutscene(this.cutscene);\n      this.soundManager.setAmbience(this.determineSiren(this.remainingDots));\n\n      this.allowPacmanMovement = true;\n      this.pacman.moving = true;\n\n      this.ghosts.forEach((ghost) => {\n        const ghostRef = ghost;\n        ghostRef.moving = true;\n      });\n\n      this.ghostCycle('scatter');\n\n      this.idleGhosts = [this.pinky, this.inky, this.clyde];\n      this.releaseGhost();\n    }, duration);\n  }\n\n  /**\n   * Clears out all children nodes from a given display element\n   * @param {String} display\n   */\n  clearDisplay(display) {\n    while (display.firstChild) {\n      display.removeChild(display.firstChild);\n    }\n  }\n\n  /**\n   * Displays extra life images equal to the number of remaining lives\n   */\n  updateExtraLivesDisplay() {\n    this.clearDisplay(this.extraLivesDisplay);\n\n    for (let i = 0; i < this.lives; i += 1) {\n      const extraLifePic = document.createElement('img');\n      extraLifePic.setAttribute('src', '/style/graphics/extra_life.svg');\n      extraLifePic.style.height = `${this.scaledTileSize * 2}px`;\n      this.extraLivesDisplay.appendChild(extraLifePic);\n    }\n  }\n\n  /**\n   * Displays a rolling log of the seven most-recently eaten fruit\n   * @param {String} rawImageSource\n   */\n  updateFruitDisplay(rawImageSource) {\n    const parsedSource = rawImageSource.slice(\n      rawImageSource.indexOf('(') + 1,\n      rawImageSource.indexOf(')'),\n    );\n\n    if (this.fruitDisplay.children.length === 7) {\n      this.fruitDisplay.removeChild(this.fruitDisplay.firstChild);\n    }\n\n    const fruitPic = document.createElement('img');\n    fruitPic.setAttribute('src', parsedSource);\n    fruitPic.style.height = `${this.scaledTileSize * 2}px`;\n    this.fruitDisplay.appendChild(fruitPic);\n  }\n\n  /**\n   * Cycles the ghosts between 'chase' and 'scatter' mode\n   * @param {('chase'|'scatter')} mode\n   */\n  ghostCycle(mode) {\n    const delay = mode === 'scatter' ? 7000 : 20000;\n    const nextMode = mode === 'scatter' ? 'chase' : 'scatter';\n\n    this.ghostCycleTimer = new Timer(() => {\n      this.ghosts.forEach((ghost) => {\n        ghost.changeMode(nextMode);\n      });\n\n      this.ghostCycle(nextMode);\n    }, delay);\n  }\n\n  /**\n   * Releases a ghost from the Ghost House after a delay\n   */\n  releaseGhost() {\n    if (this.idleGhosts.length > 0) {\n      const delay = Math.max((8 - (this.level - 1) * 4) * 1000, 0);\n\n      this.endIdleTimer = new Timer(() => {\n        this.idleGhosts[0].endIdleMode();\n        this.idleGhosts.shift();\n      }, delay);\n    }\n  }\n\n  /**\n   * Register listeners for various game sequences\n   */\n  registerEventListeners() {\n    window.addEventListener('keydown', this.handleKeyDown.bind(this));\n    window.addEventListener('awardPoints', this.awardPoints.bind(this));\n    window.addEventListener('deathSequence', this.deathSequence.bind(this));\n    window.addEventListener('dotEaten', this.dotEaten.bind(this));\n    window.addEventListener('powerUp', this.powerUp.bind(this));\n    window.addEventListener('eatGhost', this.eatGhost.bind(this));\n    window.addEventListener('restoreGhost', this.restoreGhost.bind(this));\n    window.addEventListener('addTimer', this.addTimer.bind(this));\n    window.addEventListener('removeTimer', this.removeTimer.bind(this));\n    window.addEventListener('releaseGhost', this.releaseGhost.bind(this));\n\n    const directions = ['up', 'down', 'left', 'right'];\n\n    directions.forEach((direction) => {\n      document\n        .getElementById(`button-${direction}`)\n        .addEventListener('touchstart', () => {\n          this.changeDirection(direction);\n        });\n    });\n  }\n\n  /**\n   * Calls Pacman's changeDirection event if certain conditions are met\n   * @param {({'up'|'down'|'left'|'right'})} direction\n   */\n  changeDirection(direction) {\n    if (this.allowKeyPresses && this.gameEngine.running) {\n      this.pacman.changeDirection(direction, this.allowPacmanMovement);\n    }\n  }\n\n  /**\n   * Calls various class functions depending upon the pressed key\n   * @param {Event} e - The keydown event to evaluate\n   */\n  handleKeyDown(e) {\n    if (e.keyCode === 27) {\n      // ESC key\n      this.handlePauseKey();\n    } else if (e.keyCode === 81) {\n      // Q\n      this.soundButtonClick();\n    } else if (this.movementKeys[e.keyCode]) {\n      this.changeDirection(this.movementKeys[e.keyCode]);\n    }\n  }\n\n  /**\n   * Handle behavior for the pause key\n   */\n  handlePauseKey() {\n    if (this.allowPause) {\n      this.allowPause = false;\n\n      setTimeout(() => {\n        if (!this.cutscene) {\n          this.allowPause = true;\n        }\n      }, 500);\n\n      this.gameEngine.changePausedState(this.gameEngine.running);\n      this.soundManager.play('pause');\n\n      if (this.gameEngine.started) {\n        this.soundManager.resumeAmbience();\n        this.gameUi.style.filter = 'unset';\n        this.movementButtons.style.filter = 'unset';\n        this.pausedText.style.visibility = 'hidden';\n        this.pauseButton.innerHTML = 'pause';\n        this.activeTimers.forEach((timer) => {\n          timer.resume();\n        });\n      } else {\n        this.soundManager.stopAmbience();\n        this.soundManager.setAmbience('pause_beat', true);\n        this.gameUi.style.filter = 'blur(5px)';\n        this.movementButtons.style.filter = 'blur(5px)';\n        this.pausedText.style.visibility = 'visible';\n        this.pauseButton.innerHTML = 'play_arrow';\n        this.activeTimers.forEach((timer) => {\n          timer.pause();\n        });\n      }\n    }\n  }\n\n  /**\n   * Adds points to the player's total\n   * @param {({ detail: { points: Number }})} e - Contains a quantity of points to add\n   */\n  awardPoints(e) {\n    this.points += e.detail.points;\n    this.pointsDisplay.innerText = this.points;\n    if (this.points > (this.highScore || 0)) {\n      this.highScore = this.points;\n      this.highScoreDisplay.innerText = this.points;\n      localStorage.setItem('highScore', this.highScore);\n    }\n\n    if (this.points >= 10000 && !this.extraLifeGiven) {\n      this.extraLifeGiven = true;\n      this.soundManager.play('extra_life');\n      this.lives += 1;\n      this.updateExtraLivesDisplay();\n    }\n\n    if (e.detail.type === 'fruit') {\n      const left = e.detail.points >= 1000\n        ? this.scaledTileSize * 12.5\n        : this.scaledTileSize * 13;\n      const top = this.scaledTileSize * 16.5;\n      const width = e.detail.points >= 1000\n        ? this.scaledTileSize * 3\n        : this.scaledTileSize * 2;\n      const height = this.scaledTileSize * 2;\n\n      this.displayText({ left, top }, e.detail.points, 2000, width, height);\n      this.soundManager.play('fruit');\n      this.updateFruitDisplay(\n        this.fruit.determineImage('fruit', e.detail.points),\n      );\n    }\n  }\n\n  /**\n   * Animates Pacman's death, subtracts a life, and resets character positions if\n   * the player has remaining lives.\n   */\n  deathSequence() {\n    this.allowPause = false;\n    this.cutscene = true;\n    this.soundManager.setCutscene(this.cutscene);\n    this.soundManager.stopAmbience();\n    this.removeTimer({ detail: { timer: this.fruitTimer } });\n    this.removeTimer({ detail: { timer: this.ghostCycleTimer } });\n    this.removeTimer({ detail: { timer: this.endIdleTimer } });\n    this.removeTimer({ detail: { timer: this.ghostFlashTimer } });\n\n    this.allowKeyPresses = false;\n    this.pacman.moving = false;\n    this.ghosts.forEach((ghost) => {\n      const ghostRef = ghost;\n      ghostRef.moving = false;\n    });\n\n    new Timer(() => {\n      this.ghosts.forEach((ghost) => {\n        const ghostRef = ghost;\n        ghostRef.display = false;\n      });\n      this.pacman.prepDeathAnimation();\n      this.soundManager.play('death');\n\n      if (this.lives > 0) {\n        this.lives -= 1;\n\n        new Timer(() => {\n          this.mazeCover.style.visibility = 'visible';\n          new Timer(() => {\n            this.allowKeyPresses = true;\n            this.mazeCover.style.visibility = 'hidden';\n            this.pacman.reset();\n            this.ghosts.forEach((ghost) => {\n              ghost.reset();\n            });\n            this.fruit.hideFruit();\n\n            this.startGameplay();\n          }, 500);\n        }, 2250);\n      } else {\n        this.gameOver();\n      }\n    }, 750);\n  }\n\n  /**\n   * Displays GAME OVER text and displays the menu so players can play again\n   */\n  executeContract() {\n    console.log(\"Execute smart contract, check and set new hight score\", this.highScore) // TODO: this should be done\n  }\n  gameOver() {\n    localStorage.setItem('highScore', this.highScore);\n    // this.executeContract()\n    executeSmartContract(this.highScore)\n    new Timer(() => {\n      this.displayText(\n        {\n          left: this.scaledTileSize * 9,\n          top: this.scaledTileSize * 16.5,\n        },\n        'game_over',\n        4000,\n        this.scaledTileSize * 10,\n        this.scaledTileSize * 2,\n      );\n      this.fruit.hideFruit();\n\n      new Timer(() => {\n        this.leftCover.style.left = '0';\n        this.rightCover.style.right = '0';\n\n        setTimeout(() => {\n          this.mainMenu.style.opacity = 1;\n          this.gameStartButton.disabled = false;\n          this.mainMenu.style.visibility = 'visible';\n        }, 1000);\n      }, 2500);\n    }, 2250);\n  }\n\n  /**\n   * Handle events related to the number of remaining dots\n   */\n  dotEaten() {\n    this.remainingDots -= 1;\n\n    this.soundManager.playDotSound();\n\n    if (this.remainingDots === 174 || this.remainingDots === 74) {\n      this.createFruit();\n    }\n\n    if (this.remainingDots === 40 || this.remainingDots === 20) {\n      this.speedUpBlinky();\n    }\n\n    if (this.remainingDots === 0) {\n      this.advanceLevel();\n    }\n  }\n\n  /**\n   * Creates a bonus fruit for ten seconds\n   */\n  createFruit() {\n    this.removeTimer({ detail: { timer: this.fruitTimer } });\n    this.fruit.showFruit(this.fruitPoints[this.level] || 5000);\n    this.fruitTimer = new Timer(() => {\n      this.fruit.hideFruit();\n    }, 10000);\n  }\n\n  /**\n   * Speeds up Blinky and raises the background noise pitch\n   */\n  speedUpBlinky() {\n    this.blinky.speedUp();\n\n    if (this.scaredGhosts.length === 0 && this.eyeGhosts === 0) {\n      this.soundManager.setAmbience(this.determineSiren(this.remainingDots));\n    }\n  }\n\n  /**\n   * Determines the correct siren ambience\n   * @param {Number} remainingDots\n   * @returns {String}\n   */\n  determineSiren(remainingDots) {\n    let sirenNum;\n\n    if (remainingDots > 40) {\n      sirenNum = 1;\n    } else if (remainingDots > 20) {\n      sirenNum = 2;\n    } else {\n      sirenNum = 3;\n    }\n\n    return `siren_${sirenNum}`;\n  }\n\n  /**\n   * Resets the gameboard and prepares the next level\n   */\n  advanceLevel() {\n    this.allowPause = false;\n    this.cutscene = true;\n    this.soundManager.setCutscene(this.cutscene);\n    this.allowKeyPresses = false;\n    this.soundManager.stopAmbience();\n\n    this.entityList.forEach((entity) => {\n      const entityRef = entity;\n      entityRef.moving = false;\n    });\n\n    this.removeTimer({ detail: { timer: this.fruitTimer } });\n    this.removeTimer({ detail: { timer: this.ghostCycleTimer } });\n    this.removeTimer({ detail: { timer: this.endIdleTimer } });\n    this.removeTimer({ detail: { timer: this.ghostFlashTimer } });\n\n    const imgBase = '/style/graphics/spriteSheets/maze/';\n\n    new Timer(() => {\n      this.ghosts.forEach((ghost) => {\n        const ghostRef = ghost;\n        ghostRef.display = false;\n      });\n\n      this.mazeImg.src = `${imgBase}maze_white.svg`;\n      new Timer(() => {\n        this.mazeImg.src = `${imgBase}maze_blue.svg`;\n        new Timer(() => {\n          this.mazeImg.src = `${imgBase}maze_white.svg`;\n          new Timer(() => {\n            this.mazeImg.src = `${imgBase}maze_blue.svg`;\n            new Timer(() => {\n              this.mazeImg.src = `${imgBase}maze_white.svg`;\n              new Timer(() => {\n                this.mazeImg.src = `${imgBase}maze_blue.svg`;\n                new Timer(() => {\n                  this.mazeCover.style.visibility = 'visible';\n                  new Timer(() => {\n                    this.mazeCover.style.visibility = 'hidden';\n                    this.level += 1;\n                    this.allowKeyPresses = true;\n                    this.entityList.forEach((entity) => {\n                      const entityRef = entity;\n                      if (entityRef.level) {\n                        entityRef.level = this.level;\n                      }\n                      entityRef.reset();\n                      if (entityRef instanceof Ghost) {\n                        entityRef.resetDefaultSpeed();\n                      }\n                      if (\n                        entityRef instanceof Pickup\n                        && entityRef.type !== 'fruit'\n                      ) {\n                        this.remainingDots += 1;\n                      }\n                    });\n                    this.startGameplay();\n                  }, 500);\n                }, 250);\n              }, 250);\n            }, 250);\n          }, 250);\n        }, 250);\n      }, 250);\n    }, 2000);\n  }\n\n  /**\n   * Flashes ghosts blue and white to indicate the end of the powerup\n   * @param {Number} flashes - Total number of elapsed flashes\n   * @param {Number} maxFlashes - Total flashes to show\n   */\n  flashGhosts(flashes, maxFlashes) {\n    if (flashes === maxFlashes) {\n      this.scaredGhosts.forEach((ghost) => {\n        ghost.endScared();\n      });\n      this.scaredGhosts = [];\n      if (this.eyeGhosts === 0) {\n        this.soundManager.setAmbience(this.determineSiren(this.remainingDots));\n      }\n    } else if (this.scaredGhosts.length > 0) {\n      this.scaredGhosts.forEach((ghost) => {\n        ghost.toggleScaredColor();\n      });\n\n      this.ghostFlashTimer = new Timer(() => {\n        this.flashGhosts(flashes + 1, maxFlashes);\n      }, 250);\n    }\n  }\n\n  /**\n   * Upon eating a power pellet, sets the ghosts to 'scared' mode\n   */\n  powerUp() {\n    if (this.remainingDots !== 0) {\n      this.soundManager.setAmbience('power_up');\n    }\n\n    this.removeTimer({ detail: { timer: this.ghostFlashTimer } });\n\n    this.ghostCombo = 0;\n    this.scaredGhosts = [];\n\n    this.ghosts.forEach((ghost) => {\n      if (ghost.mode !== 'eyes') {\n        this.scaredGhosts.push(ghost);\n      }\n    });\n\n    this.scaredGhosts.forEach((ghost) => {\n      ghost.becomeScared();\n    });\n\n    const powerDuration = Math.max((7 - this.level) * 1000, 0);\n    this.ghostFlashTimer = new Timer(() => {\n      this.flashGhosts(0, 9);\n    }, powerDuration);\n  }\n\n  /**\n   * Determines the quantity of points to give based on the current combo\n   */\n  determineComboPoints() {\n    return 100 * (2 ** this.ghostCombo);\n  }\n\n  /**\n   * Upon eating a ghost, award points and temporarily pause movement\n   * @param {CustomEvent} e - Contains a target ghost object\n   */\n  eatGhost(e) {\n    const pauseDuration = 1000;\n    const { position, measurement } = e.detail.ghost;\n\n    this.pauseTimer({ detail: { timer: this.ghostFlashTimer } });\n    this.pauseTimer({ detail: { timer: this.ghostCycleTimer } });\n    this.pauseTimer({ detail: { timer: this.fruitTimer } });\n    this.soundManager.play('eat_ghost');\n\n    this.scaredGhosts = this.scaredGhosts.filter(\n      ghost => ghost.name !== e.detail.ghost.name,\n    );\n    this.eyeGhosts += 1;\n\n    this.ghostCombo += 1;\n    const comboPoints = this.determineComboPoints();\n    window.dispatchEvent(\n      new CustomEvent('awardPoints', {\n        detail: {\n          points: comboPoints,\n        },\n      }),\n    );\n    this.displayText(position, comboPoints, pauseDuration, measurement);\n\n    this.allowPacmanMovement = false;\n    this.pacman.display = false;\n    this.pacman.moving = false;\n    e.detail.ghost.display = false;\n    e.detail.ghost.moving = false;\n\n    this.ghosts.forEach((ghost) => {\n      const ghostRef = ghost;\n      ghostRef.animate = false;\n      ghostRef.pause(true);\n      ghostRef.allowCollision = false;\n    });\n\n    new Timer(() => {\n      this.soundManager.setAmbience('eyes');\n\n      this.resumeTimer({ detail: { timer: this.ghostFlashTimer } });\n      this.resumeTimer({ detail: { timer: this.ghostCycleTimer } });\n      this.resumeTimer({ detail: { timer: this.fruitTimer } });\n      this.allowPacmanMovement = true;\n      this.pacman.display = true;\n      this.pacman.moving = true;\n      e.detail.ghost.display = true;\n      e.detail.ghost.moving = true;\n      this.ghosts.forEach((ghost) => {\n        const ghostRef = ghost;\n        ghostRef.animate = true;\n        ghostRef.pause(false);\n        ghostRef.allowCollision = true;\n      });\n    }, pauseDuration);\n  }\n\n  /**\n   * Decrements the count of \"eye\" ghosts and updates the ambience\n   */\n  restoreGhost() {\n    this.eyeGhosts -= 1;\n\n    if (this.eyeGhosts === 0) {\n      const sound = this.scaredGhosts.length > 0\n        ? 'power_up'\n        : this.determineSiren(this.remainingDots);\n      this.soundManager.setAmbience(sound);\n    }\n  }\n\n  /**\n   * Creates a temporary div to display points on screen\n   * @param {({ left: number, top: number })} position - CSS coordinates to display the points at\n   * @param {Number} amount - Amount of points to display\n   * @param {Number} duration - Milliseconds to display the points before disappearing\n   * @param {Number} width - Image width in pixels\n   * @param {Number} height - Image height in pixels\n   */\n  displayText(position, amount, duration, width, height) {\n    const pointsDiv = document.createElement('div');\n\n    pointsDiv.style.position = 'absolute';\n    pointsDiv.style.backgroundSize = `${width}px`;\n    pointsDiv.style.backgroundImage = 'url(/style/graphics/'\n        + `spriteSheets/text/${amount}.svg`;\n    pointsDiv.style.width = `${width}px`;\n    pointsDiv.style.height = `${height || width}px`;\n    pointsDiv.style.top = `${position.top}px`;\n    pointsDiv.style.left = `${position.left}px`;\n    pointsDiv.style.zIndex = 2;\n\n    this.mazeDiv.appendChild(pointsDiv);\n\n    new Timer(() => {\n      this.mazeDiv.removeChild(pointsDiv);\n    }, duration);\n  }\n\n  /**\n   * Pushes a Timer to the activeTimers array\n   * @param {({ detail: { timer: Object }})} e\n   */\n  addTimer(e) {\n    this.activeTimers.push(e.detail.timer);\n  }\n\n  /**\n   * Checks if a Timer with a matching ID exists\n   * @param {({ detail: { timer: Object }})} e\n   * @returns {Boolean}\n   */\n  timerExists(e) {\n    return !!(e.detail.timer || {}).timerId;\n  }\n\n  /**\n   * Pauses a timer\n   * @param {({ detail: { timer: Object }})} e\n   */\n  pauseTimer(e) {\n    if (this.timerExists(e)) {\n      e.detail.timer.pause(true);\n    }\n  }\n\n  /**\n   * Resumes a timer\n   * @param {({ detail: { timer: Object }})} e\n   */\n  resumeTimer(e) {\n    if (this.timerExists(e)) {\n      e.detail.timer.resume(true);\n    }\n  }\n\n  /**\n   * Removes a Timer from activeTimers\n   * @param {({ detail: { timer: Object }})} e\n   */\n  removeTimer(e) {\n    if (this.timerExists(e)) {\n      window.clearTimeout(e.detail.timer.timerId);\n      this.activeTimers = this.activeTimers.filter(\n        timer => timer.timerId !== e.detail.timer.timerId,\n      );\n    }\n  }\n}\n\n\nclass GameEngine {\n  constructor(maxFps, entityList) {\n    this.fpsDisplay = document.getElementById('fps-display');\n    this.elapsedMs = 0;\n    this.lastFrameTimeMs = 0;\n    this.entityList = entityList;\n    this.maxFps = maxFps;\n    this.timestep = 1000 / this.maxFps;\n    this.fps = this.maxFps;\n    this.framesThisSecond = 0;\n    this.lastFpsUpdate = 0;\n    this.frameId = 0;\n    this.running = false;\n    this.started = false;\n  }\n\n  /**\n   * Toggles the paused/running status of the game\n   * @param {Boolean} running - Whether the game is currently in motion\n   */\n  changePausedState(running) {\n    if (running) {\n      this.stop();\n    } else {\n      this.start();\n    }\n  }\n\n  /**\n   * Updates the on-screen FPS counter once per second\n   * @param {number} timestamp - The amount of MS which has passed since starting the game engine\n   */\n  updateFpsDisplay(timestamp) {\n    if (timestamp > this.lastFpsUpdate + 1000) {\n      this.fps = (this.framesThisSecond + this.fps) / 2;\n      this.lastFpsUpdate = timestamp;\n      this.framesThisSecond = 0;\n    }\n    this.framesThisSecond += 1;\n    this.fpsDisplay.textContent = `${Math.round(this.fps)} FPS`;\n  }\n\n  /**\n   * Calls the draw function for every member of the entityList\n   * @param {number} interp - The animation accuracy as a percentage\n   * @param {Array} entityList - List of entities to be used throughout the game\n   */\n  draw(interp, entityList) {\n    entityList.forEach((entity) => {\n      if (typeof entity.draw === 'function') {\n        entity.draw(interp);\n      }\n    });\n  }\n\n  /**\n   * Calls the update function for every member of the entityList\n   * @param {number} elapsedMs - The amount of MS that have passed since the last update\n   * @param {Array} entityList - List of entities to be used throughout the game\n   */\n  update(elapsedMs, entityList) {\n    entityList.forEach((entity) => {\n      if (typeof entity.update === 'function') {\n        entity.update(elapsedMs);\n      }\n    });\n  }\n\n  /**\n   * In the event that a ton of unsimulated frames pile up, discard all of these frames\n   * to prevent crashing the game\n   */\n  panic() {\n    this.elapsedMs = 0;\n  }\n\n  /**\n   * Draws an initial frame, resets a few tracking variables related to animation, and calls\n   * the mainLoop function to start the engine\n   */\n  start() {\n    if (!this.started) {\n      this.started = true;\n\n      this.frameId = requestAnimationFrame((firstTimestamp) => {\n        this.draw(1, []);\n        this.running = true;\n        this.lastFrameTimeMs = firstTimestamp;\n        this.lastFpsUpdate = firstTimestamp;\n        this.framesThisSecond = 0;\n\n        this.frameId = requestAnimationFrame((timestamp) => {\n          this.mainLoop(timestamp);\n        });\n      });\n    }\n  }\n\n  /**\n   * Stops the engine and cancels the current animation frame\n   */\n  stop() {\n    this.running = false;\n    this.started = false;\n    cancelAnimationFrame(this.frameId);\n  }\n\n  /**\n   * The loop which will process all necessary frames to update the game's entities\n   * prior to animating them\n   */\n  processFrames() {\n    let numUpdateSteps = 0;\n    while (this.elapsedMs >= this.timestep) {\n      this.update(this.timestep, this.entityList);\n      this.elapsedMs -= this.timestep;\n      numUpdateSteps += 1;\n      if (numUpdateSteps >= this.maxFps) {\n        this.panic();\n        break;\n      }\n    }\n  }\n\n  /**\n   * A single cycle of the engine which checks to see if enough time has passed, and, if so,\n   * will kick off the loops to update and draw the game's entities.\n   * @param {number} timestamp - The amount of MS which has passed since starting the game engine\n   */\n  engineCycle(timestamp) {\n    if (timestamp < this.lastFrameTimeMs + (1000 / this.maxFps)) {\n      this.frameId = requestAnimationFrame((nextTimestamp) => {\n        this.mainLoop(nextTimestamp);\n      });\n      return;\n    }\n\n    this.elapsedMs += timestamp - this.lastFrameTimeMs;\n    this.lastFrameTimeMs = timestamp;\n    this.updateFpsDisplay(timestamp);\n    this.processFrames();\n    this.draw(this.elapsedMs / this.timestep, this.entityList);\n\n    this.frameId = requestAnimationFrame((nextTimestamp) => {\n      this.mainLoop(nextTimestamp);\n    });\n  }\n\n  /**\n   * The endless loop which will kick off engine cycles so long as the game is running\n   * @param {number} timestamp - The amount of MS which has passed since starting the game engine\n   */\n  mainLoop(timestamp) {\n    this.engineCycle(timestamp);\n  }\n}\n\n\nclass Pickup {\n  constructor(type, scaledTileSize, column, row, pacman, mazeDiv, points) {\n    this.type = type;\n    this.pacman = pacman;\n    this.mazeDiv = mazeDiv;\n    this.points = points;\n    this.nearPacman = false;\n\n    this.fruitImages = {\n      100: 'cherry',\n      300: 'strawberry',\n      500: 'orange',\n      700: 'apple',\n      1000: 'melon',\n      2000: 'galaxian',\n      3000: 'bell',\n      5000: 'key',\n    };\n\n    this.setStyleMeasurements(type, scaledTileSize, column, row, points);\n  }\n\n  /**\n   * Resets the pickup's visibility\n   */\n  reset() {\n    this.animationTarget.style.visibility = (this.type === 'fruit')\n      ? 'hidden' : 'visible';\n  }\n\n  /**\n   * Sets various style measurements for the pickup depending on its type\n   * @param {('pacdot'|'powerPellet'|'fruit')} type - The classification of pickup\n   * @param {number} scaledTileSize\n   * @param {number} column\n   * @param {number} row\n   * @param {number} points\n   */\n  setStyleMeasurements(type, scaledTileSize, column, row, points) {\n    if (type === 'pacdot') {\n      this.size = scaledTileSize * 0.25;\n      this.x = (column * scaledTileSize) + ((scaledTileSize / 8) * 3);\n      this.y = (row * scaledTileSize) + ((scaledTileSize / 8) * 3);\n    } else if (type === 'powerPellet') {\n      this.size = scaledTileSize;\n      this.x = (column * scaledTileSize);\n      this.y = (row * scaledTileSize);\n    } else {\n      this.size = scaledTileSize * 2;\n      this.x = (column * scaledTileSize) - (scaledTileSize * 0.5);\n      this.y = (row * scaledTileSize) - (scaledTileSize * 0.5);\n    }\n\n    this.center = {\n      x: column * scaledTileSize,\n      y: row * scaledTileSize,\n    };\n\n    this.animationTarget = document.createElement('div');\n    this.animationTarget.style.position = 'absolute';\n    this.animationTarget.style.backgroundSize = `${this.size}px`;\n    this.animationTarget.style.backgroundImage = this.determineImage(\n      type, points,\n    );\n    this.animationTarget.style.height = `${this.size}px`;\n    this.animationTarget.style.width = `${this.size}px`;\n    this.animationTarget.style.top = `${this.y}px`;\n    this.animationTarget.style.left = `${this.x}px`;\n    this.mazeDiv.appendChild(this.animationTarget);\n\n    if (type === 'powerPellet') {\n      this.animationTarget.classList.add('power-pellet');\n    }\n\n    this.reset();\n  }\n\n  /**\n   * Determines the Pickup image based on type and point value\n   * @param {('pacdot'|'powerPellet'|'fruit')} type - The classification of pickup\n   * @param {Number} points\n   * @returns {String}\n   */\n  determineImage(type, points) {\n    let image = '';\n\n    if (type === 'fruit') {\n      image = this.fruitImages[points] || 'cherry';\n    } else {\n      image = type;\n    }\n\n    return `url(/style/graphics/spriteSheets/pickups/${image}.svg)`;\n  }\n\n  /**\n   * Shows a bonus fruit, resetting its point value and image\n   * @param {number} points\n   */\n  showFruit(points) {\n    this.points = points;\n    this.animationTarget.style.backgroundImage = this.determineImage(\n      this.type, points,\n    );\n    this.animationTarget.style.visibility = 'visible';\n  }\n\n  /**\n   * Makes the fruit invisible (happens if Pacman was too slow)\n   */\n  hideFruit() {\n    this.animationTarget.style.visibility = 'hidden';\n  }\n\n  /**\n   * Returns true if the Pickup is touching a bounding box at Pacman's center\n   * @param {({ x: number, y: number, size: number})} pickup\n   * @param {({ x: number, y: number, size: number})} originalPacman\n   */\n  checkForCollision(pickup, originalPacman) {\n    const pacman = Object.assign({}, originalPacman);\n\n    pacman.x += (pacman.size * 0.25);\n    pacman.y += (pacman.size * 0.25);\n    pacman.size /= 2;\n\n    return (pickup.x < pacman.x + pacman.size\n      && pickup.x + pickup.size > pacman.x\n      && pickup.y < pacman.y + pacman.size\n      && pickup.y + pickup.size > pacman.y);\n  }\n\n  /**\n   * Checks to see if the pickup is close enough to Pacman to be considered for collision detection\n   * @param {number} maxDistance - The maximum distance Pacman can travel per cycle\n   * @param {({ x:number, y:number })} pacmanCenter - The center of Pacman's hitbox\n   * @param {Boolean} debugging - Flag to change the appearance of pickups for testing\n   */\n  checkPacmanProximity(maxDistance, pacmanCenter, debugging) {\n    if (this.animationTarget.style.visibility !== 'hidden') {\n      const distance = Math.sqrt(\n        ((this.center.x - pacmanCenter.x) ** 2)\n        + ((this.center.y - pacmanCenter.y) ** 2),\n      );\n\n      this.nearPacman = (distance <= maxDistance);\n\n      if (debugging) {\n        this.animationTarget.style.background = this.nearPacman\n          ? 'lime' : 'red';\n      }\n    }\n  }\n\n  /**\n   * Checks if the pickup is visible and close to Pacman\n   * @returns {Boolean}\n   */\n  shouldCheckForCollision() {\n    return this.animationTarget.style.visibility !== 'hidden'\n      && this.nearPacman;\n  }\n\n  /**\n   * If the Pickup is still visible, it checks to see if it is colliding with Pacman.\n   * It will turn itself invisible and cease collision-detection after the first\n   * collision with Pacman.\n   */\n  update() {\n    if (this.shouldCheckForCollision()) {\n      if (this.checkForCollision(\n        {\n          x: this.x,\n          y: this.y,\n          size: this.size,\n        }, {\n          x: this.pacman.position.left,\n          y: this.pacman.position.top,\n          size: this.pacman.measurement,\n        },\n      )) {\n        this.animationTarget.style.visibility = 'hidden';\n        window.dispatchEvent(new CustomEvent('awardPoints', {\n          detail: {\n            points: this.points,\n            type: this.type,\n          },\n        }));\n\n        if (this.type === 'pacdot') {\n          window.dispatchEvent(new Event('dotEaten'));\n        } else if (this.type === 'powerPellet') {\n          window.dispatchEvent(new Event('dotEaten'));\n          window.dispatchEvent(new Event('powerUp'));\n        }\n      }\n    }\n  }\n}\n\n\nclass CharacterUtil {\n  constructor() {\n    this.directions = {\n      up: 'up',\n      down: 'down',\n      left: 'left',\n      right: 'right',\n    };\n  }\n\n  /**\n   * Check if a given character has moved more than five in-game tiles during a frame.\n   * If so, we want to temporarily hide the object to avoid 'animation stutter'.\n   * @param {({top: number, left: number})} position - Position during the current frame\n   * @param {({top: number, left: number})} oldPosition - Position during the previous frame\n   * @returns {('hidden'|'visible')} - The new 'visibility' css property value for the character.\n   */\n  checkForStutter(position, oldPosition) {\n    let stutter = false;\n    const threshold = 5;\n\n    if (position && oldPosition) {\n      if (Math.abs(position.top - oldPosition.top) > threshold\n        || Math.abs(position.left - oldPosition.left) > threshold) {\n        stutter = true;\n      }\n    }\n\n    return stutter ? 'hidden' : 'visible';\n  }\n\n  /**\n   * Check which CSS property needs to be changed given the character's current direction\n   * @param {('up'|'down'|'left'|'right')} direction - The character's current travel orientation\n   * @returns {('top'|'left')}\n   */\n  getPropertyToChange(direction) {\n    switch (direction) {\n      case this.directions.up:\n      case this.directions.down:\n        return 'top';\n      default:\n        return 'left';\n    }\n  }\n\n  /**\n   * Calculate the velocity for the character's next frame.\n   * @param {('up'|'down'|'left'|'right')} direction - The character's current travel orientation\n   * @param {number} velocityPerMs - The distance to travel in a single millisecond\n   * @returns {number} - Moving down or right is positive, while up or left is negative.\n   */\n  getVelocity(direction, velocityPerMs) {\n    switch (direction) {\n      case this.directions.up:\n      case this.directions.left:\n        return velocityPerMs * -1;\n      default:\n        return velocityPerMs;\n    }\n  }\n\n  /**\n   * Determine the next value which will be used to draw the character's position on screen\n   * @param {number} interp - The percentage of the desired timestamp between frames\n   * @param {('top'|'left')} prop - The css property to be changed\n   * @param {({top: number, left: number})} oldPosition - Position during the previous frame\n   * @param {({top: number, left: number})} position - Position during the current frame\n   * @returns {number} - New value for css positioning\n   */\n  calculateNewDrawValue(interp, prop, oldPosition, position) {\n    return oldPosition[prop] + (position[prop] - oldPosition[prop]) * interp;\n  }\n\n  /**\n   * Convert the character's css position to a row-column on the maze array\n   * @param {('up'|'down'|'left'|'right')} direction - The character's current travel orientation\n   * @param {number} scaledTileSize - The dimensions of a single tile\n   * @returns {({x: number, y: number})}\n   */\n  determineGridPosition(position, scaledTileSize) {\n    return {\n      x: (position.left / scaledTileSize) + 0.5,\n      y: (position.top / scaledTileSize) + 0.5,\n    };\n  }\n\n  /**\n   * Check to see if a character's disired direction results in turning around\n   * @param {('up'|'down'|'left'|'right')} direction - The character's current travel orientation\n   * @param {('up'|'down'|'left'|'right')} desiredDirection - Character's desired orientation\n   * @returns {boolean}\n   */\n  turningAround(direction, desiredDirection) {\n    return desiredDirection === this.getOppositeDirection(direction);\n  }\n\n  /**\n   * Calculate the opposite of a given direction\n   * @param {('up'|'down'|'left'|'right')} direction - The character's current travel orientation\n   * @returns {('up'|'down'|'left'|'right')}\n   */\n  getOppositeDirection(direction) {\n    switch (direction) {\n      case this.directions.up:\n        return this.directions.down;\n      case this.directions.down:\n        return this.directions.up;\n      case this.directions.left:\n        return this.directions.right;\n      default:\n        return this.directions.left;\n    }\n  }\n\n  /**\n   * Calculate the proper rounding function to assist with collision detection\n   * @param {('up'|'down'|'left'|'right')} direction - The character's current travel orientation\n   * @returns {Function}\n   */\n  determineRoundingFunction(direction) {\n    switch (direction) {\n      case this.directions.up:\n      case this.directions.left:\n        return Math.floor;\n      default:\n        return Math.ceil;\n    }\n  }\n\n  /**\n   * Check to see if the character's next frame results in moving to a new tile on the maze array\n   * @param {({x: number, y: number})} oldPosition - Position during the previous frame\n   * @param {({x: number, y: number})} position - Position during the current frame\n   * @returns {boolean}\n   */\n  changingGridPosition(oldPosition, position) {\n    return (\n      Math.floor(oldPosition.x) !== Math.floor(position.x)\n            || Math.floor(oldPosition.y) !== Math.floor(position.y)\n    );\n  }\n\n  /**\n   * Check to see if the character is attempting to run into a wall of the maze\n   * @param {({x: number, y: number})} desiredNewGridPosition - Character's target tile\n   * @param {Array} mazeArray - The 2D array representing the game's maze\n   * @param {('up'|'down'|'left'|'right')} direction - The character's current travel orientation\n   * @returns {boolean}\n   */\n  checkForWallCollision(desiredNewGridPosition, mazeArray, direction) {\n    const roundingFunction = this.determineRoundingFunction(\n      direction, this.directions,\n    );\n\n    const desiredX = roundingFunction(desiredNewGridPosition.x);\n    const desiredY = roundingFunction(desiredNewGridPosition.y);\n    let newGridValue;\n\n    if (Array.isArray(mazeArray[desiredY])) {\n      newGridValue = mazeArray[desiredY][desiredX];\n    }\n\n    return (newGridValue === 'X');\n  }\n\n  /**\n   * Returns an object containing the new position and grid position based upon a direction\n   * @param {({top: number, left: number})} position - css position during the current frame\n   * @param {('up'|'down'|'left'|'right')} direction - The character's current travel orientation\n   * @param {number} velocityPerMs - The distance to travel in a single millisecond\n   * @param {number} elapsedMs - The amount of MS that have passed since the last update\n   * @param {number} scaledTileSize - The dimensions of a single tile\n   * @returns {object}\n   */\n  determineNewPositions(\n    position, direction, velocityPerMs, elapsedMs, scaledTileSize,\n  ) {\n    const newPosition = Object.assign({}, position);\n    newPosition[this.getPropertyToChange(direction)]\n      += this.getVelocity(direction, velocityPerMs) * elapsedMs;\n    const newGridPosition = this.determineGridPosition(\n      newPosition, scaledTileSize,\n    );\n\n    return {\n      newPosition,\n      newGridPosition,\n    };\n  }\n\n  /**\n   * Calculates the css position when snapping the character to the x-y grid\n   * @param {({x: number, y: number})} position - The character's position during the current frame\n   * @param {('up'|'down'|'left'|'right')} direction - The character's current travel orientation\n   * @param {number} scaledTileSize - The dimensions of a single tile\n   * @returns {({top: number, left: number})}\n   */\n  snapToGrid(position, direction, scaledTileSize) {\n    const newPosition = Object.assign({}, position);\n    const roundingFunction = this.determineRoundingFunction(\n      direction, this.directions,\n    );\n\n    switch (direction) {\n      case this.directions.up:\n      case this.directions.down:\n        newPosition.y = roundingFunction(newPosition.y);\n        break;\n      default:\n        newPosition.x = roundingFunction(newPosition.x);\n        break;\n    }\n\n    return {\n      top: (newPosition.y - 0.5) * scaledTileSize,\n      left: (newPosition.x - 0.5) * scaledTileSize,\n    };\n  }\n\n  /**\n   * Returns a modified position if the character needs to warp\n   * @param {({top: number, left: number})} position - css position during the current frame\n   * @param {({x: number, y: number})} gridPosition - x-y position during the current frame\n   * @param {number} scaledTileSize - The dimensions of a single tile\n   * @returns {({top: number, left: number})}\n   */\n  handleWarp(position, scaledTileSize, mazeArray) {\n    const newPosition = Object.assign({}, position);\n    const gridPosition = this.determineGridPosition(position, scaledTileSize);\n\n    if (gridPosition.x < -0.75) {\n      newPosition.left = (scaledTileSize * (mazeArray[0].length - 0.75));\n    } else if (gridPosition.x > (mazeArray[0].length - 0.25)) {\n      newPosition.left = (scaledTileSize * -1.25);\n    }\n\n    return newPosition;\n  }\n\n  /**\n   * Advances spritesheet by one frame if needed\n   * @param {Object} character - The character which needs to be animated\n   */\n  advanceSpriteSheet(character) {\n    const {\n      msSinceLastSprite,\n      animationTarget,\n      backgroundOffsetPixels,\n    } = character;\n    const updatedProperties = {\n      msSinceLastSprite,\n      animationTarget,\n      backgroundOffsetPixels,\n    };\n\n    const ready = (character.msSinceLastSprite > character.msBetweenSprites)\n      && character.animate;\n    if (ready) {\n      updatedProperties.msSinceLastSprite = 0;\n\n      if (character.backgroundOffsetPixels\n        < (character.measurement * (character.spriteFrames - 1))\n      ) {\n        updatedProperties.backgroundOffsetPixels += character.measurement;\n      } else if (character.loopAnimation) {\n        updatedProperties.backgroundOffsetPixels = 0;\n      }\n\n      const style = `-${updatedProperties.backgroundOffsetPixels}px 0px`;\n      updatedProperties.animationTarget.style.backgroundPosition = style;\n    }\n\n    return updatedProperties;\n  }\n}\n\n\nclass SoundManager {\n  constructor() {\n    this.baseUrl = '/style/audio/';\n    this.fileFormat = 'mp3';\n    this.masterVolume = 1;\n    this.paused = false;\n    this.cutscene = true;\n\n    const AudioContext = window.AudioContext || window.webkitAudioContext;\n    this.ambience = new AudioContext();\n  }\n\n  /**\n   * Sets the cutscene flag to determine if players should be able to resume ambience\n   * @param {Boolean} newValue\n   */\n  setCutscene(newValue) {\n    this.cutscene = newValue;\n  }\n\n  /**\n   * Sets the master volume for all sounds and stops/resumes ambience\n   * @param {(0|1)} newVolume\n   */\n  setMasterVolume(newVolume) {\n    this.masterVolume = newVolume;\n\n    if (this.soundEffect) {\n      this.soundEffect.volume = this.masterVolume;\n    }\n\n    if (this.dotPlayer) {\n      this.dotPlayer.volume = this.masterVolume;\n    }\n\n    if (this.masterVolume === 0) {\n      this.stopAmbience();\n    } else {\n      this.resumeAmbience(this.paused);\n    }\n  }\n\n  /**\n   * Plays a single sound effect\n   * @param {String} sound\n   */\n  play(sound) {\n    this.soundEffect = new Audio(`${this.baseUrl}${sound}.${this.fileFormat}`);\n    this.soundEffect.volume = this.masterVolume;\n    this.soundEffect.play();\n  }\n\n  /**\n   * Special method for eating dots. The dots should alternate between two\n   * sound effects, but not too quickly.\n   */\n  playDotSound() {\n    this.queuedDotSound = true;\n\n    if (!this.dotPlayer) {\n      this.queuedDotSound = false;\n      this.dotSound = (this.dotSound === 1) ? 2 : 1;\n\n      this.dotPlayer = new Audio(\n        `${this.baseUrl}dot_${this.dotSound}.${this.fileFormat}`,\n      );\n      this.dotPlayer.onended = this.dotSoundEnded.bind(this);\n      this.dotPlayer.volume = this.masterVolume;\n      this.dotPlayer.play();\n    }\n  }\n\n  /**\n   * Deletes the dotSound player and plays another dot sound if needed\n   */\n  dotSoundEnded() {\n    this.dotPlayer = undefined;\n\n    if (this.queuedDotSound) {\n      this.playDotSound();\n    }\n  }\n\n  /**\n   * Loops an ambient sound\n   * @param {String} sound\n   */\n  async setAmbience(sound, keepCurrentAmbience) {\n    if (!this.fetchingAmbience && !this.cutscene) {\n      if (!keepCurrentAmbience) {\n        this.currentAmbience = sound;\n        this.paused = false;\n      } else {\n        this.paused = true;\n      }\n\n      if (this.ambienceSource) {\n        this.ambienceSource.stop();\n      }\n\n      if (this.masterVolume !== 0) {\n        this.fetchingAmbience = true;\n        const response = await fetch(\n          `${this.baseUrl}${sound}.${this.fileFormat}`,\n        );\n        const arrayBuffer = await response.arrayBuffer();\n        const audioBuffer = await this.ambience.decodeAudioData(arrayBuffer);\n\n        this.ambienceSource = this.ambience.createBufferSource();\n        this.ambienceSource.buffer = audioBuffer;\n        this.ambienceSource.connect(this.ambience.destination);\n        this.ambienceSource.loop = true;\n        this.ambienceSource.start();\n\n        this.fetchingAmbience = false;\n      }\n    }\n  }\n\n  /**\n   * Resumes the ambience\n   */\n  resumeAmbience(paused) {\n    if (this.ambienceSource) {\n      // Resetting the ambience since an AudioBufferSourceNode can only\n      // have 'start()' called once\n      if (paused) {\n        this.setAmbience('pause_beat', true);\n      } else {\n        this.setAmbience(this.currentAmbience);\n      }\n    }\n  }\n\n  /**\n   * Stops the ambience\n   */\n  stopAmbience() {\n    if (this.ambienceSource) {\n      this.ambienceSource.stop();\n    }\n  }\n}\n\n\nclass Timer {\n  constructor(callback, delay) {\n    this.callback = callback;\n    this.remaining = delay;\n    this.resume();\n  }\n\n  /**\n   * Pauses the timer marks whether the pause came from the player\n   * or the system\n   * @param {Boolean} systemPause\n   */\n  pause(systemPause) {\n    window.clearTimeout(this.timerId);\n    this.remaining -= new Date() - this.start;\n    this.oldTimerId = this.timerId;\n\n    if (systemPause) {\n      this.pausedBySystem = true;\n    }\n  }\n\n  /**\n   * Creates a new setTimeout based upon the remaining time, giving the\n   * illusion of 'resuming' the old setTimeout\n   * @param {Boolean} systemResume\n   */\n  resume(systemResume) {\n    if (systemResume || !this.pausedBySystem) {\n      this.pausedBySystem = false;\n\n      this.start = new Date();\n      this.timerId = window.setTimeout(() => {\n        this.callback();\n        window.dispatchEvent(new CustomEvent('removeTimer', {\n          detail: {\n            timer: this,\n          },\n        }));\n      }, this.remaining);\n\n      if (!this.oldTimerId) {\n        window.dispatchEvent(new CustomEvent('addTimer', {\n          detail: {\n            timer: this,\n          },\n        }));\n      }\n    }\n  }\n}\n"],"names":["console","log","$7fc2474486b8416c$var$Ghost","constructor","scaledTileSize","mazeArray","pacman","name","level","characterUtil","blinky","animationTarget","document","getElementById","reset","fullGameReset","defaultSpeed","cruiseElroy","setDefaultMode","setMovementStats","setSpriteAnimationStats","setStyleMeasurements","spriteFrames","setDefaultPosition","setSpriteSheet","direction","mode","allowCollision","defaultMode","idleMode","pacmanSpeed","velocityPerMs","levelAdjustment","slowSpeed","mediumSpeed","fastSpeed","scaredSpeed","transitionSpeed","eyeSpeed","moving","defaultDirection","directions","left","down","up","display","loopAnimation","animate","msBetweenSprites","msSinceLastSprite","backgroundOffsetPixels","style","backgroundPosition","measurement","height","width","bgSize","backgroundSize","defaultPosition","top","position","Object","assign","oldPosition","emotion","backgroundImage","scaredColor","isInTunnel","gridPosition","y","x","isInGhostHouse","getTile","tile","determinePossibleMoves","possibleMoves","right","getOppositeDirection","keys","forEach","calculateDistance","Math","sqrt","getPositionInFrontOfPacman","pacmanGridPosition","spaces","target","pacDirection","determinePinkyTarget","determineInkyTarget","blinkyGridPosition","determineGridPosition","pivotPoint","determineClydeTarget","distance","getTarget","determineBestMove","bestMove","bestDistance","Infinity","move","betterMove","determineDirection","newDirection","length","handleIdleMovement","elapsedMs","velocity","newPosition","undefined","window","dispatchEvent","Event","getPropertyToChange","getVelocity","endIdleMode","handleSnappedMovement","enteringGhostHouse","enteredGhostHouse","leavingGhostHouse","handleGhostHouse","gridPositionCopy","snapToGrid","handleUnsnappedMovement","desired","determineNewPositions","changingGridPosition","newGridPosition","handleMovement","determineVelocity","JSON","stringify","handleWarp","checkCollision","changeMode","newMode","toggleScaredColor","becomeScared","endScared","speedUp","resetDefaultSpeed","pause","newValue","paused","CustomEvent","detail","ghost","draw","interp","newTop","calculateNewDrawValue","newLeft","visibility","checkForStutter","updatedProperties","advanceSpriteSheet","update","$7fc2474486b8416c$var$Pacman","pacmanArrow","calculateVelocityPerMs","desiredDirection","specialAnimation","velocityPerSecond","prepDeathAnimation","changeDirection","startMoving","updatePacmanArrowPosition","alternate","checkForWallCollision","turningAround","$7fc2474486b8416c$export$fb4646ab13eb7425","gameUi","rowTop","mazeDiv","mazeImg","mazeCover","pointsDisplay","highScoreDisplay","extraLivesDisplay","fruitDisplay","mainMenu","gameStartButton","pauseButton","soundButton","leftCover","rightCover","pausedText","bottomRow","movementButtons","maxFps","tileSize","scale","determineScale","firstGame","movementKeys","fruitPoints","row","rowIndex","split","addEventListener","startButtonClick","bind","handlePauseKey","soundButtonClick","setTimeout","preloadAssets","availableScreenHeight","min","documentElement","clientHeight","innerHeight","availableScreenWidth","clientWidth","innerWidth","mazeTileHeight","mazeTileWidth","opacity","disabled","init","startGameplay","newVolume","soundManager","masterVolume","setMasterVolume","localStorage","setItem","setSoundButtonIcon","innerHTML","displayErrorMessage","loadingContainer","errorMessage","remove","Promise","resolve","loadingPacman","loadingDotMask","imgBase","imgSources","audioBase","audioSources","totalSources","remainingSources","all","createElements","then","catch","e","sources","type","gameCoord","preloadDiv","containerWidth","scrollWidth","reject","loadedSources","source","element","Image","Audio","appendChild","elementReady","gameCoordRef","percent","onload","onerror","src","load","activeTimers","points","lives","extraLifeGiven","remainingDots","allowKeyPresses","allowPacmanMovement","allowPause","cutscene","highScore","getItem","setInterval","collisionDetectionLoop","$7fc2474486b8416c$var$CharacterUtil","pinky","inky","clyde","fruit","$7fc2474486b8416c$var$Pickup","entityList","ghosts","scaredGhosts","eyeGhosts","drawMaze","$7fc2474486b8416c$var$SoundManager","setUiDimensions","pickups","pickup","push","clearDisplay","volumePreference","parseInt","registerEventListeners","gameEngine","$7fc2474486b8416c$var$GameEngine","start","minHeight","dotContainer","block","columnIndex","dot","fontSize","marginBottom","maxDistance","pacmanCenter","checkPacmanProximity","initialStart","play","duration","displayText","updateExtraLivesDisplay","$7fc2474486b8416c$var$Timer","setCutscene","setAmbience","determineSiren","ghostRef","ghostCycle","idleGhosts","releaseGhost","firstChild","removeChild","i","extraLifePic","createElement","setAttribute","updateFruitDisplay","rawImageSource","parsedSource","slice","indexOf","children","fruitPic","nextMode","ghostCycleTimer","delay","max","endIdleTimer","shift","handleKeyDown","awardPoints","deathSequence","dotEaten","powerUp","eatGhost","restoreGhost","addTimer","removeTimer","running","keyCode","changePausedState","started","resumeAmbience","filter","timer","resume","stopAmbience","innerText","determineImage","fruitTimer","ghostFlashTimer","hideFruit","gameOver","executeContract","executeSmartContract","playDotSound","createFruit","speedUpBlinky","advanceLevel","showFruit","entity","entityRef","flashGhosts","flashes","maxFlashes","ghostCombo","powerDuration","determineComboPoints","pauseTimer","comboPoints","resumeTimer","sound","amount","pointsDiv","zIndex","timerExists","timerId","clearTimeout","fpsDisplay","lastFrameTimeMs","timestep","fps","framesThisSecond","lastFpsUpdate","frameId","stop","updateFpsDisplay","timestamp","textContent","round","panic","requestAnimationFrame","firstTimestamp","mainLoop","cancelAnimationFrame","processFrames","numUpdateSteps","engineCycle","nextTimestamp","column","nearPacman","fruitImages","size","center","classList","add","checkForCollision","originalPacman","debugging","background","shouldCheckForCollision","stutter","abs","prop","determineRoundingFunction","floor","ceil","desiredNewGridPosition","newGridValue","roundingFunction","desiredX","desiredY","Array","isArray","character","ready","baseUrl","fileFormat","AudioContext","webkitAudioContext","ambience","soundEffect","volume","dotPlayer","queuedDotSound","dotSound","onended","dotSoundEnded","keepCurrentAmbience","fetchingAmbience","currentAmbience","ambienceSource","response","fetch","arrayBuffer","audioBuffer","decodeAudioData","createBufferSource","buffer","connect","destination","loop","callback","remaining","systemPause","Date","oldTimerId","pausedBySystem","systemResume","$3260655c7f105486$var$loadScoreboard","responseList","scoreElements"],"version":3,"file":"index.016fbd5b.js.map"}